   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"os_task.c"
  21              	.Ltext0:
  22              		.file 1 "../os_core/os_task.c"
 1635              		.align	2
 1636              		.global	OSTaskChangePrio
 1638              	OSTaskChangePrio:
 1639              	.LFB0:
   1:../os_core/os_task.c **** /*
   2:../os_core/os_task.c **** ***************************************************************************************************
   3:../os_core/os_task.c **** *                                                uC/OS-II
   4:../os_core/os_task.c **** *                                          The Real-Time Kernel
   5:../os_core/os_task.c **** *                                            TASK MANAGEMENT
   6:../os_core/os_task.c **** *
   7:../os_core/os_task.c **** *                          (c) Copyright 1992-2003, Jean J. Labrosse, Weston, FL
   8:../os_core/os_task.c **** *                                           All Rights Reserved
   9:../os_core/os_task.c **** *
  10:../os_core/os_task.c **** * File    : OS_TASK.C
  11:../os_core/os_task.c **** * By      : Jean J. Labrosse
  12:../os_core/os_task.c **** * Version : V2.76
  13:../os_core/os_task.c **** ***************************************************************************************************
  14:../os_core/os_task.c **** */
  15:../os_core/os_task.c **** 
  16:../os_core/os_task.c **** #ifndef  OS_MASTER_FILE
  17:../os_core/os_task.c **** #include "ucos_ii.h"
  18:../os_core/os_task.c **** #endif
  19:../os_core/os_task.c **** 
  20:../os_core/os_task.c **** /*
  21:../os_core/os_task.c **** ***************************************************************************************************
  22:../os_core/os_task.c **** *                                        CHANGE PRIORITY OF A TASK
  23:../os_core/os_task.c **** *
  24:../os_core/os_task.c **** * Description: This function allows you to change the priority of a task dynamically.  Note that th
  25:../os_core/os_task.c **** *              priority MUST be available.
  26:../os_core/os_task.c **** *
  27:../os_core/os_task.c **** * Arguments  : oldp     is the old priority
  28:../os_core/os_task.c **** *
  29:../os_core/os_task.c **** *              newp     is the new priority
  30:../os_core/os_task.c **** *
  31:../os_core/os_task.c **** * Returns    : OS_NO_ERR          is the call was successful
  32:../os_core/os_task.c **** *              OS_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
  33:../os_core/os_task.c **** *                                 (i.e. >= OS_LOWEST_PRIO)
  34:../os_core/os_task.c **** *              OS_PRIO_EXIST      if the new priority already exist.
  35:../os_core/os_task.c **** *              OS_PRIO_ERR        there is no task with the specified OLD priority (i.e. the OLD ta
  36:../os_core/os_task.c **** *                                 not exist.
  37:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
  38:../os_core/os_task.c **** ***************************************************************************************************
  39:../os_core/os_task.c **** */
  40:../os_core/os_task.c **** 
  41:../os_core/os_task.c **** #if OS_TASK_CHANGE_PRIO_EN > 0
  42:../os_core/os_task.c **** INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
  43:../os_core/os_task.c **** {
 1640              		.loc 1 43 0
 1641              		.cfi_startproc
 1642              		@ Function supports interworking.
 1643              		@ args = 0, pretend = 0, frame = 24
 1644              		@ frame_needed = 1, uses_anonymous_args = 0
 1645 0000 0DC0A0E1 		mov	ip, sp
 1646              	.LCFI0:
 1647              		.cfi_def_cfa_register 12
 1648 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1649 0008 04B04CE2 		sub	fp, ip, #4
 1650              		.cfi_offset 14, -8
 1651              		.cfi_offset 13, -12
 1652              		.cfi_offset 11, -16
 1653              	.LCFI1:
 1654              		.cfi_def_cfa 11, 4
 1655 000c 18D04DE2 		sub	sp, sp, #24
 1656 0010 0020A0E1 		mov	r2, r0
 1657 0014 0130A0E1 		mov	r3, r1
 1658 0018 1D204BE5 		strb	r2, [fp, #-29]
 1659 001c 1E304BE5 		strb	r3, [fp, #-30]
  44:../os_core/os_task.c **** #if OS_EVENT_EN
  45:../os_core/os_task.c ****     OS_EVENT    *pevent;
  46:../os_core/os_task.c **** #endif
  47:../os_core/os_task.c ****     OS_TCB      *ptcb;
  48:../os_core/os_task.c ****     INT8U        x;
  49:../os_core/os_task.c ****     INT8U        y;
  50:../os_core/os_task.c ****     INT8U        bitx;
  51:../os_core/os_task.c ****     INT8U        bity;
  52:../os_core/os_task.c ****     INT8U        y_old;
  53:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                                     
  54:../os_core/os_task.c ****     OS_CPU_SR    cpu_sr;                                        /* Storage for CPU status register 
  55:../os_core/os_task.c **** 
  56:../os_core/os_task.c **** 
  57:../os_core/os_task.c **** 
  58:../os_core/os_task.c ****     cpu_sr = 0;                                                 /* Prevent compiler warning        
  59:../os_core/os_task.c **** #endif    
  60:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
  61:../os_core/os_task.c ****     if (oldprio >= OS_LOWEST_PRIO) {
 1660              		.loc 1 61 0
 1661 0020 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 1662 0024 3E0053E3 		cmp	r3, #62
 1663 0028 0400009A 		bls	.L2
  62:../os_core/os_task.c **** 	    if (oldprio != OS_PRIO_SELF) {
 1664              		.loc 1 62 0
 1665 002c 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 1666 0030 FF0053E3 		cmp	r3, #255
 1667 0034 0100000A 		beq	.L2
  63:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 1668              		.loc 1 63 0
 1669 0038 2A30A0E3 		mov	r3, #42
 1670 003c D70000EA 		b	.L3
 1671              	.L2:
  64:../os_core/os_task.c **** 		}
  65:../os_core/os_task.c **** 	}
  66:../os_core/os_task.c ****     if (newprio >= OS_LOWEST_PRIO) {
 1672              		.loc 1 66 0
 1673 0040 1E305BE5 		ldrb	r3, [fp, #-30]	@ zero_extendqisi2
 1674 0044 3E0053E3 		cmp	r3, #62
 1675 0048 0100009A 		bls	.L4
  67:../os_core/os_task.c ****         return (OS_PRIO_INVALID);
 1676              		.loc 1 67 0
 1677 004c 2A30A0E3 		mov	r3, #42
 1678 0050 D20000EA 		b	.L3
 1679              	.L4:
  68:../os_core/os_task.c ****     }
  69:../os_core/os_task.c **** #endif
  70:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 1680              		.loc 1 70 0
 1681              	@ 70 "../os_core/os_task.c" 1
 1682 0054 00000FE1 		mrs   r0, cpsr              
 1683 0058 04002DE5 	stmfd sp!, {r0}             
 1684 005c C00080E3 	orr   r0, r0, #0b11000000   
 1685 0060 00F021E1 	msr   cpsr_c, r0              
 1686              	@ 0 "" 2
  71:../os_core/os_task.c ****     if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already ex
 1687              		.loc 1 71 0
 1688 0064 1E205BE5 		ldrb	r2, [fp, #-30]	@ zero_extendqisi2
 1689 0068 40339FE5 		ldr	r3, .L13
 1690 006c 023193E7 		ldr	r3, [r3, r2, asl #2]
 1691 0070 000053E3 		cmp	r3, #0
 1692 0074 0300000A 		beq	.L5
  72:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 1693              		.loc 1 72 0
 1694              	@ 72 "../os_core/os_task.c" 1
 1695 0078 04009DE4 		ldmfd sp!, {r0}             
 1696 007c 00F021E1 	msr   cpsr_c, r0              
 1697              	@ 0 "" 2
  73:../os_core/os_task.c ****         return (OS_PRIO_EXIST);
 1698              		.loc 1 73 0
 1699 0080 2830A0E3 		mov	r3, #40
 1700 0084 C50000EA 		b	.L3
 1701              	.L5:
  74:../os_core/os_task.c ****     } 
  75:../os_core/os_task.c ****     if (oldprio == OS_PRIO_SELF) {                              /* See if changing self            
 1702              		.loc 1 75 0
 1703 0088 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 1704 008c FF0053E3 		cmp	r3, #255
 1705 0090 0300001A 		bne	.L6
  76:../os_core/os_task.c ****         oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority               
 1706              		.loc 1 76 0
 1707 0094 18339FE5 		ldr	r3, .L13+4
 1708 0098 003093E5 		ldr	r3, [r3, #0]
 1709 009c 2E30D3E5 		ldrb	r3, [r3, #46]
 1710 00a0 1D304BE5 		strb	r3, [fp, #-29]
 1711              	.L6:
  77:../os_core/os_task.c ****     }
  78:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[oldprio];
 1712              		.loc 1 78 0
 1713 00a4 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 1714 00a8 00339FE5 		ldr	r3, .L13
 1715 00ac 023193E7 		ldr	r3, [r3, r2, asl #2]
 1716 00b0 10300BE5 		str	r3, [fp, #-16]
  79:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?      
 1717              		.loc 1 79 0
 1718 00b4 10301BE5 		ldr	r3, [fp, #-16]
 1719 00b8 000053E3 		cmp	r3, #0
 1720 00bc 0300001A 		bne	.L7
  80:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                                     /* No, can't change its priority!  
 1721              		.loc 1 80 0
 1722              	@ 80 "../os_core/os_task.c" 1
 1723 00c0 04009DE4 		ldmfd sp!, {r0}             
 1724 00c4 00F021E1 	msr   cpsr_c, r0              
 1725              	@ 0 "" 2
  81:../os_core/os_task.c ****         return (OS_PRIO_ERR);
 1726              		.loc 1 81 0
 1727 00c8 2930A0E3 		mov	r3, #41
 1728 00cc B30000EA 		b	.L3
 1729              	.L7:
  82:../os_core/os_task.c ****     }                                       
  83:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex       
 1730              		.loc 1 83 0
 1731 00d0 10301BE5 		ldr	r3, [fp, #-16]
 1732 00d4 010053E3 		cmp	r3, #1
 1733 00d8 0300001A 		bne	.L8
  84:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                                     /* No, can't change its priority!  
 1734              		.loc 1 84 0
 1735              	@ 84 "../os_core/os_task.c" 1
 1736 00dc 04009DE4 		ldmfd sp!, {r0}             
 1737 00e0 00F021E1 	msr   cpsr_c, r0              
 1738              	@ 0 "" 2
  85:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 1739              		.loc 1 85 0
 1740 00e4 0B30A0E3 		mov	r3, #11
 1741 00e8 AC0000EA 		b	.L3
 1742              	.L8:
  86:../os_core/os_task.c ****     }                                       
  87:../os_core/os_task.c ****     y                     = newprio >> 3;                       /* Yes, compute new TCB fields     
 1743              		.loc 1 87 0
 1744 00ec 1E305BE5 		ldrb	r3, [fp, #-30]	@ zero_extendqisi2
 1745 00f0 A331A0E1 		mov	r3, r3, lsr #3
 1746 00f4 11304BE5 		strb	r3, [fp, #-17]
  88:../os_core/os_task.c ****     bity                  = OSMapTbl[y];
 1747              		.loc 1 88 0
 1748 00f8 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1749 00fc B4229FE5 		ldr	r2, .L13+8
 1750 0100 0330D2E7 		ldrb	r3, [r2, r3]
 1751 0104 12304BE5 		strb	r3, [fp, #-18]
  89:../os_core/os_task.c ****     x                     = newprio & 0x07;
 1752              		.loc 1 89 0
 1753 0108 1E305BE5 		ldrb	r3, [fp, #-30]
 1754 010c 073003E2 		and	r3, r3, #7
 1755 0110 13304BE5 		strb	r3, [fp, #-19]
  90:../os_core/os_task.c ****     bitx                  = OSMapTbl[x];
 1756              		.loc 1 90 0
 1757 0114 13305BE5 		ldrb	r3, [fp, #-19]	@ zero_extendqisi2
 1758 0118 98229FE5 		ldr	r2, .L13+8
 1759 011c 0330D2E7 		ldrb	r3, [r2, r3]
 1760 0120 14304BE5 		strb	r3, [fp, #-20]
  91:../os_core/os_task.c ****     OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority    
 1761              		.loc 1 91 0
 1762 0124 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 1763 0128 80329FE5 		ldr	r3, .L13
 1764 012c 0010A0E3 		mov	r1, #0
 1765 0130 021183E7 		str	r1, [r3, r2, asl #2]
  92:../os_core/os_task.c ****     OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new prior
 1766              		.loc 1 92 0
 1767 0134 1E205BE5 		ldrb	r2, [fp, #-30]	@ zero_extendqisi2
 1768 0138 70329FE5 		ldr	r3, .L13
 1769 013c 10101BE5 		ldr	r1, [fp, #-16]
 1770 0140 021183E7 		str	r1, [r3, r2, asl #2]
  93:../os_core/os_task.c ****     y_old                 = ptcb->OSTCBY;
 1771              		.loc 1 93 0
 1772 0144 10301BE5 		ldr	r3, [fp, #-16]
 1773 0148 3030D3E5 		ldrb	r3, [r3, #48]
 1774 014c 15304BE5 		strb	r3, [fp, #-21]
  94:../os_core/os_task.c ****     if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not    
 1775              		.loc 1 94 0
 1776 0150 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 1777 0154 60229FE5 		ldr	r2, .L13+12
 1778 0158 0320D2E7 		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 1779 015c 10301BE5 		ldr	r3, [fp, #-16]
 1780 0160 3130D3E5 		ldrb	r3, [r3, #49]	@ zero_extendqisi2
 1781 0164 033002E0 		and	r3, r2, r3
 1782 0168 FF3003E2 		and	r3, r3, #255
 1783 016c 000053E3 		cmp	r3, #0
 1784 0170 3100000A 		beq	.L9
  95:../os_core/os_task.c ****         OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
 1785              		.loc 1 95 0
 1786 0174 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 1787 0178 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 1788 017c 38129FE5 		ldr	r1, .L13+12
 1789 0180 0220D1E7 		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 1790 0184 FF1002E2 		and	r1, r2, #255
 1791 0188 10201BE5 		ldr	r2, [fp, #-16]
 1792 018c 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 1793 0190 FF2002E2 		and	r2, r2, #255
 1794 0194 0220E0E1 		mvn	r2, r2
 1795 0198 FF2002E2 		and	r2, r2, #255
 1796 019c 022001E0 		and	r2, r1, r2
 1797 01a0 FF2002E2 		and	r2, r2, #255
 1798 01a4 FF1002E2 		and	r1, r2, #255
 1799 01a8 0C229FE5 		ldr	r2, .L13+12
 1800 01ac 0310C2E7 		strb	r1, [r2, r3]
  96:../os_core/os_task.c ****         if (OSRdyTbl[y_old] == 0x00) {
 1801              		.loc 1 96 0
 1802 01b0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 1803 01b4 00229FE5 		ldr	r2, .L13+12
 1804 01b8 0330D2E7 		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1805 01bc 000053E3 		cmp	r3, #0
 1806 01c0 0C00001A 		bne	.L10
  97:../os_core/os_task.c ****             OSRdyGrp &= ~ptcb->OSTCBBitY;
 1807              		.loc 1 97 0
 1808 01c4 10301BE5 		ldr	r3, [fp, #-16]
 1809 01c8 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 1810 01cc FF3003E2 		and	r3, r3, #255
 1811 01d0 0330E0E1 		mvn	r3, r3
 1812 01d4 FF2003E2 		and	r2, r3, #255
 1813 01d8 E0319FE5 		ldr	r3, .L13+16
 1814 01dc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1815 01e0 FF3003E2 		and	r3, r3, #255
 1816 01e4 033002E0 		and	r3, r2, r3
 1817 01e8 FF3003E2 		and	r3, r3, #255
 1818 01ec FF2003E2 		and	r2, r3, #255
 1819 01f0 C8319FE5 		ldr	r3, .L13+16
 1820 01f4 0020C3E5 		strb	r2, [r3, #0]
 1821              	.L10:
  98:../os_core/os_task.c ****         }
  99:../os_core/os_task.c ****         OSRdyGrp    |= bity;                                    /* Make new priority ready to run  
 1822              		.loc 1 99 0
 1823 01f8 C0319FE5 		ldr	r3, .L13+16
 1824 01fc 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1825 0200 12305BE5 		ldrb	r3, [fp, #-18]
 1826 0204 033082E1 		orr	r3, r2, r3
 1827 0208 FF2003E2 		and	r2, r3, #255
 1828 020c AC319FE5 		ldr	r3, .L13+16
 1829 0210 0020C3E5 		strb	r2, [r3, #0]
 100:../os_core/os_task.c ****         OSRdyTbl[y] |= bitx;
 1830              		.loc 1 100 0
 1831 0214 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1832 0218 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 1833 021c 98119FE5 		ldr	r1, .L13+12
 1834 0220 0210D1E7 		ldrb	r1, [r1, r2]	@ zero_extendqisi2
 1835 0224 14205BE5 		ldrb	r2, [fp, #-20]
 1836 0228 022081E1 		orr	r2, r1, r2
 1837 022c FF1002E2 		and	r1, r2, #255
 1838 0230 84219FE5 		ldr	r2, .L13+12
 1839 0234 0310C2E7 		strb	r1, [r2, r3]
 1840 0238 450000EA 		b	.L11
 1841              	.L9:
 101:../os_core/os_task.c **** #if OS_EVENT_EN
 102:../os_core/os_task.c ****     } else {                                                    /* Task was not ready ...          
 103:../os_core/os_task.c ****         pevent = ptcb->OSTCBEventPtr;
 1842              		.loc 1 103 0
 1843 023c 10301BE5 		ldr	r3, [fp, #-16]
 1844 0240 1C3093E5 		ldr	r3, [r3, #28]
 1845 0244 1C300BE5 		str	r3, [fp, #-28]
 104:../os_core/os_task.c ****         if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list 
 1846              		.loc 1 104 0
 1847 0248 1C301BE5 		ldr	r3, [fp, #-28]
 1848 024c 000053E3 		cmp	r3, #0
 1849 0250 3F00000A 		beq	.L11
 105:../os_core/os_task.c ****             pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
 1850              		.loc 1 105 0
 1851 0254 15105BE5 		ldrb	r1, [fp, #-21]	@ zero_extendqisi2
 1852 0258 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 1853 025c 1C001BE5 		ldr	r0, [fp, #-28]
 1854 0260 0830A0E3 		mov	r3, #8
 1855 0264 022080E0 		add	r2, r0, r2
 1856 0268 033082E0 		add	r3, r2, r3
 1857 026c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1858 0270 FF2003E2 		and	r2, r3, #255
 1859 0274 10301BE5 		ldr	r3, [fp, #-16]
 1860 0278 3130D3E5 		ldrb	r3, [r3, #49]	@ zero_extendqisi2
 1861 027c FF3003E2 		and	r3, r3, #255
 1862 0280 0330E0E1 		mvn	r3, r3
 1863 0284 FF3003E2 		and	r3, r3, #255
 1864 0288 033002E0 		and	r3, r2, r3
 1865 028c FF3003E2 		and	r3, r3, #255
 1866 0290 FF2003E2 		and	r2, r3, #255
 1867 0294 1C001BE5 		ldr	r0, [fp, #-28]
 1868 0298 0830A0E3 		mov	r3, #8
 1869 029c 011080E0 		add	r1, r0, r1
 1870 02a0 033081E0 		add	r3, r1, r3
 1871 02a4 0020C3E5 		strb	r2, [r3, #0]
 106:../os_core/os_task.c ****             if (pevent->OSEventTbl[y_old] == 0) {
 1872              		.loc 1 106 0
 1873 02a8 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 1874 02ac 1C101BE5 		ldr	r1, [fp, #-28]
 1875 02b0 0830A0E3 		mov	r3, #8
 1876 02b4 022081E0 		add	r2, r1, r2
 1877 02b8 033082E0 		add	r3, r2, r3
 1878 02bc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1879 02c0 000053E3 		cmp	r3, #0
 1880 02c4 0C00001A 		bne	.L12
 107:../os_core/os_task.c ****                 pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 1881              		.loc 1 107 0
 1882 02c8 1C301BE5 		ldr	r3, [fp, #-28]
 1883 02cc 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1884 02d0 FF2003E2 		and	r2, r3, #255
 1885 02d4 10301BE5 		ldr	r3, [fp, #-16]
 1886 02d8 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 1887 02dc FF3003E2 		and	r3, r3, #255
 1888 02e0 0330E0E1 		mvn	r3, r3
 1889 02e4 FF3003E2 		and	r3, r3, #255
 1890 02e8 033002E0 		and	r3, r2, r3
 1891 02ec FF3003E2 		and	r3, r3, #255
 1892 02f0 FF2003E2 		and	r2, r3, #255
 1893 02f4 1C301BE5 		ldr	r3, [fp, #-28]
 1894 02f8 0120C3E5 		strb	r2, [r3, #1]
 1895              	.L12:
 108:../os_core/os_task.c ****             }
 109:../os_core/os_task.c ****             pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list   
 1896              		.loc 1 109 0
 1897 02fc 1C301BE5 		ldr	r3, [fp, #-28]
 1898 0300 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1899 0304 12305BE5 		ldrb	r3, [fp, #-18]
 1900 0308 033082E1 		orr	r3, r2, r3
 1901 030c FF2003E2 		and	r2, r3, #255
 1902 0310 1C301BE5 		ldr	r3, [fp, #-28]
 1903 0314 0120C3E5 		strb	r2, [r3, #1]
 110:../os_core/os_task.c ****             pevent->OSEventTbl[y] |= bitx;
 1904              		.loc 1 110 0
 1905 0318 11105BE5 		ldrb	r1, [fp, #-17]	@ zero_extendqisi2
 1906 031c 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 1907 0320 1C001BE5 		ldr	r0, [fp, #-28]
 1908 0324 0830A0E3 		mov	r3, #8
 1909 0328 022080E0 		add	r2, r0, r2
 1910 032c 033082E0 		add	r3, r2, r3
 1911 0330 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1912 0334 14305BE5 		ldrb	r3, [fp, #-20]
 1913 0338 033082E1 		orr	r3, r2, r3
 1914 033c FF2003E2 		and	r2, r3, #255
 1915 0340 1C001BE5 		ldr	r0, [fp, #-28]
 1916 0344 0830A0E3 		mov	r3, #8
 1917 0348 011080E0 		add	r1, r0, r1
 1918 034c 033081E0 		add	r3, r1, r3
 1919 0350 0020C3E5 		strb	r2, [r3, #0]
 1920              	.L11:
 111:../os_core/os_task.c ****         }
 112:../os_core/os_task.c **** #endif
 113:../os_core/os_task.c ****     }
 114:../os_core/os_task.c ****     ptcb->OSTCBPrio = newprio;                                  /* Set new task priority           
 1921              		.loc 1 114 0
 1922 0354 10301BE5 		ldr	r3, [fp, #-16]
 1923 0358 1E205BE5 		ldrb	r2, [fp, #-30]
 1924 035c 2E20C3E5 		strb	r2, [r3, #46]
 115:../os_core/os_task.c ****     ptcb->OSTCBY    = y;
 1925              		.loc 1 115 0
 1926 0360 10301BE5 		ldr	r3, [fp, #-16]
 1927 0364 11205BE5 		ldrb	r2, [fp, #-17]
 1928 0368 3020C3E5 		strb	r2, [r3, #48]
 116:../os_core/os_task.c ****     ptcb->OSTCBX    = x;
 1929              		.loc 1 116 0
 1930 036c 10301BE5 		ldr	r3, [fp, #-16]
 1931 0370 13205BE5 		ldrb	r2, [fp, #-19]
 1932 0374 2F20C3E5 		strb	r2, [r3, #47]
 117:../os_core/os_task.c ****     ptcb->OSTCBBitY = bity;
 1933              		.loc 1 117 0
 1934 0378 10301BE5 		ldr	r3, [fp, #-16]
 1935 037c 12205BE5 		ldrb	r2, [fp, #-18]
 1936 0380 3220C3E5 		strb	r2, [r3, #50]
 118:../os_core/os_task.c ****     ptcb->OSTCBBitX = bitx;
 1937              		.loc 1 118 0
 1938 0384 10301BE5 		ldr	r3, [fp, #-16]
 1939 0388 14205BE5 		ldrb	r2, [fp, #-20]
 1940 038c 3120C3E5 		strb	r2, [r3, #49]
 119:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 1941              		.loc 1 119 0
 1942              	@ 119 "../os_core/os_task.c" 1
 1943 0390 04009DE4 		ldmfd sp!, {r0}             
 1944 0394 00F021E1 	msr   cpsr_c, r0              
 1945              	@ 0 "" 2
 120:../os_core/os_task.c ****     OS_Sched();                                                 /* Run highest priority task ready 
 1946              		.loc 1 120 0
 1947 0398 FEFFFFEB 		bl	OS_Sched
 121:../os_core/os_task.c ****     return (OS_NO_ERR);
 1948              		.loc 1 121 0
 1949 039c 0030A0E3 		mov	r3, #0
 1950              	.L3:
 122:../os_core/os_task.c **** }
 1951              		.loc 1 122 0
 1952 03a0 0300A0E1 		mov	r0, r3
 1953 03a4 0CD04BE2 		sub	sp, fp, #12
 1954 03a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1955 03ac 1EFF2FE1 		bx	lr
 1956              	.L14:
 1957              		.align	2
 1958              	.L13:
 1959 03b0 00000000 		.word	OSTCBPrioTbl
 1960 03b4 00000000 		.word	OSTCBCur
 1961 03b8 00000000 		.word	OSMapTbl
 1962 03bc 00000000 		.word	OSRdyTbl
 1963 03c0 00000000 		.word	OSRdyGrp
 1964              		.cfi_endproc
 1965              	.LFE0:
 1967              		.align	2
 1968              		.global	OSTaskCreate
 1970              	OSTaskCreate:
 1971              	.LFB1:
 123:../os_core/os_task.c **** #endif
 124:../os_core/os_task.c **** /*$PAGE*/
 125:../os_core/os_task.c **** /*
 126:../os_core/os_task.c **** ***************************************************************************************************
 127:../os_core/os_task.c **** *                                            CREATE A TASK
 128:../os_core/os_task.c **** *
 129:../os_core/os_task.c **** * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can ei
 130:../os_core/os_task.c **** *              be created prior to the start of multitasking or by a running task.  A task cannot b
 131:../os_core/os_task.c **** *              created by an ISR.
 132:../os_core/os_task.c **** *
 133:../os_core/os_task.c **** * Arguments  : task     is a pointer to the task's code
 134:../os_core/os_task.c **** *
 135:../os_core/os_task.c **** *              p_arg    is a pointer to an optional data area which can be used to pass parameters 
 136:../os_core/os_task.c **** *                       the task when the task first executes.  Where the task is concerned it thin
 137:../os_core/os_task.c **** *                       it was invoked and passed the argument 'p_arg' as follows:
 138:../os_core/os_task.c **** *
 139:../os_core/os_task.c **** *                           void Task (void *p_arg)
 140:../os_core/os_task.c **** *                           {
 141:../os_core/os_task.c **** *                               for (;;) {
 142:../os_core/os_task.c **** *                                   Task code;
 143:../os_core/os_task.c **** *                               }
 144:../os_core/os_task.c **** *                           }
 145:../os_core/os_task.c **** *
 146:../os_core/os_task.c **** *              ptos     is a pointer to the task's top of stack.  If the configuration constant
 147:../os_core/os_task.c **** *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from
 148:../os_core/os_task.c **** *                       memory to low memory).  'pstk' will thus point to the highest (valid) memor
 149:../os_core/os_task.c **** *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to 
 150:../os_core/os_task.c **** *                       lowest memory location of the stack and the stack will grow with increasing
 151:../os_core/os_task.c **** *                       memory locations.
 152:../os_core/os_task.c **** *
 153:../os_core/os_task.c **** *              prio     is the task's priority.  A unique priority MUST be assigned to each task an
 154:../os_core/os_task.c **** *                       lower the number, the higher the priority.
 155:../os_core/os_task.c **** *
 156:../os_core/os_task.c **** * Returns    : OS_NO_ERR               if the function was successful.
 157:../os_core/os_task.c **** *              OS_PRIO_EXIT            if the task priority already exist
 158:../os_core/os_task.c **** *                                      (each task MUST have a unique priority).
 159:../os_core/os_task.c **** *              OS_PRIO_INVALID         if the priority you specify is higher that the maximum allow
 160:../os_core/os_task.c **** *                                      (i.e. >= OS_LOWEST_PRIO)
 161:../os_core/os_task.c **** *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
 162:../os_core/os_task.c **** ***************************************************************************************************
 163:../os_core/os_task.c **** */
 164:../os_core/os_task.c **** 
 165:../os_core/os_task.c **** #if OS_TASK_CREATE_EN > 0
 166:../os_core/os_task.c **** INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
 167:../os_core/os_task.c **** {
 1972              		.loc 1 167 0
 1973              		.cfi_startproc
 1974              		@ Function supports interworking.
 1975              		@ args = 0, pretend = 0, frame = 24
 1976              		@ frame_needed = 1, uses_anonymous_args = 0
 1977 03c4 0DC0A0E1 		mov	ip, sp
 1978              	.LCFI2:
 1979              		.cfi_def_cfa_register 12
 1980 03c8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1981 03cc 04B04CE2 		sub	fp, ip, #4
 1982              		.cfi_offset 14, -8
 1983              		.cfi_offset 13, -12
 1984              		.cfi_offset 11, -16
 1985              	.LCFI3:
 1986              		.cfi_def_cfa 11, 4
 1987 03d0 28D04DE2 		sub	sp, sp, #40
 1988 03d4 18000BE5 		str	r0, [fp, #-24]
 1989 03d8 1C100BE5 		str	r1, [fp, #-28]
 1990 03dc 20200BE5 		str	r2, [fp, #-32]
 1991 03e0 21304BE5 		strb	r3, [fp, #-33]
 168:../os_core/os_task.c ****     OS_STK    *psp;
 169:../os_core/os_task.c ****     INT8U      err;
 170:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register           
 171:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 172:../os_core/os_task.c **** 
 173:../os_core/os_task.c **** 
 174:../os_core/os_task.c **** 
 175:../os_core/os_task.c ****     cpu_sr = 0;                              /* Prevent compiler warning                           
 176:../os_core/os_task.c **** #endif    
 177:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 178:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range       
 1992              		.loc 1 178 0
 1993 03e4 21305BE5 		ldrb	r3, [fp, #-33]	@ zero_extendqisi2
 1994 03e8 3F0053E3 		cmp	r3, #63
 1995 03ec 0100009A 		bls	.L16
 179:../os_core/os_task.c ****         return (OS_PRIO_INVALID);
 1996              		.loc 1 179 0
 1997 03f0 2A30A0E3 		mov	r3, #42
 1998 03f4 420000EA 		b	.L17
 1999              	.L16:
 180:../os_core/os_task.c ****     }
 181:../os_core/os_task.c **** #endif
 182:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2000              		.loc 1 182 0
 2001              	@ 182 "../os_core/os_task.c" 1
 2002 03f8 00000FE1 		mrs   r0, cpsr              
 2003 03fc 04002DE5 	stmfd sp!, {r0}             
 2004 0400 C00080E3 	orr   r0, r0, #0b11000000   
 2005 0404 00F021E1 	msr   cpsr_c, r0              
 2006              	@ 0 "" 2
 183:../os_core/os_task.c ****     if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an I
 2007              		.loc 1 183 0
 2008 0408 04319FE5 		ldr	r3, .L22
 2009 040c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2010 0410 000053E3 		cmp	r3, #0
 2011 0414 0300000A 		beq	.L18
 184:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2012              		.loc 1 184 0
 2013              	@ 184 "../os_core/os_task.c" 1
 2014 0418 04009DE4 		ldmfd sp!, {r0}             
 2015 041c 00F021E1 	msr   cpsr_c, r0              
 2016              	@ 0 "" 2
 185:../os_core/os_task.c ****         return (OS_ERR_TASK_CREATE_ISR);
 2017              		.loc 1 185 0
 2018 0420 1030A0E3 		mov	r3, #16
 2019 0424 360000EA 		b	.L17
 2020              	.L18:
 186:../os_core/os_task.c ****     }
 187:../os_core/os_task.c ****     if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priori
 2021              		.loc 1 187 0
 2022 0428 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2023 042c E4309FE5 		ldr	r3, .L22+4
 2024 0430 023193E7 		ldr	r3, [r3, r2, asl #2]
 2025 0434 000053E3 		cmp	r3, #0
 2026 0438 2E00001A 		bne	.L19
 188:../os_core/os_task.c ****         OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing .
 2027              		.loc 1 188 0
 2028 043c 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2029 0440 D0309FE5 		ldr	r3, .L22+4
 2030 0444 0110A0E3 		mov	r1, #1
 2031 0448 021183E7 		str	r1, [r3, r2, asl #2]
 189:../os_core/os_task.c ****                                              /* ... the same thing until task is created.          
 190:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2032              		.loc 1 190 0
 2033              	@ 190 "../os_core/os_task.c" 1
 2034 044c 04009DE4 		ldmfd sp!, {r0}             
 2035 0450 00F021E1 	msr   cpsr_c, r0              
 2036              	@ 0 "" 2
 191:../os_core/os_task.c ****         psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack     
 2037              		.loc 1 191 0
 2038 0454 18001BE5 		ldr	r0, [fp, #-24]
 2039 0458 1C101BE5 		ldr	r1, [fp, #-28]
 2040 045c 20201BE5 		ldr	r2, [fp, #-32]
 2041 0460 0030A0E3 		mov	r3, #0
 2042 0464 FEFFFFEB 		bl	OSTaskStkInit
 2043 0468 10000BE5 		str	r0, [fp, #-16]
 192:../os_core/os_task.c ****         err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 2044              		.loc 1 192 0
 2045 046c 21305BE5 		ldrb	r3, [fp, #-33]	@ zero_extendqisi2
 2046 0470 0020A0E3 		mov	r2, #0
 2047 0474 00208DE5 		str	r2, [sp, #0]
 2048 0478 0020A0E3 		mov	r2, #0
 2049 047c 04208DE5 		str	r2, [sp, #4]
 2050 0480 0020A0E3 		mov	r2, #0
 2051 0484 08208DE5 		str	r2, [sp, #8]
 2052 0488 0300A0E1 		mov	r0, r3
 2053 048c 10101BE5 		ldr	r1, [fp, #-16]
 2054 0490 0020A0E3 		mov	r2, #0
 2055 0494 0030A0E3 		mov	r3, #0
 2056 0498 FEFFFFEB 		bl	OS_TCBInit
 2057 049c 0030A0E1 		mov	r3, r0
 2058 04a0 11304BE5 		strb	r3, [fp, #-17]
 193:../os_core/os_task.c ****         if (err == OS_NO_ERR) {
 2059              		.loc 1 193 0
 2060 04a4 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2061 04a8 000053E3 		cmp	r3, #0
 2062 04ac 0500001A 		bne	.L20
 194:../os_core/os_task.c ****             if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has star
 2063              		.loc 1 194 0
 2064 04b0 64309FE5 		ldr	r3, .L22+8
 2065 04b4 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2066 04b8 010053E3 		cmp	r3, #1
 2067 04bc 0B00001A 		bne	.L21
 195:../os_core/os_task.c ****                 OS_Sched();
 2068              		.loc 1 195 0
 2069 04c0 FEFFFFEB 		bl	OS_Sched
 2070 04c4 090000EA 		b	.L21
 2071              	.L20:
 196:../os_core/os_task.c ****             }
 197:../os_core/os_task.c ****         } else {
 198:../os_core/os_task.c ****             OS_ENTER_CRITICAL();
 2072              		.loc 1 198 0
 2073              	@ 198 "../os_core/os_task.c" 1
 2074 04c8 00000FE1 		mrs   r0, cpsr              
 2075 04cc 04002DE5 	stmfd sp!, {r0}             
 2076 04d0 C00080E3 	orr   r0, r0, #0b11000000   
 2077 04d4 00F021E1 	msr   cpsr_c, r0              
 2078              	@ 0 "" 2
 199:../os_core/os_task.c ****             OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others             
 2079              		.loc 1 199 0
 2080 04d8 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2081 04dc 34309FE5 		ldr	r3, .L22+4
 2082 04e0 0010A0E3 		mov	r1, #0
 2083 04e4 021183E7 		str	r1, [r3, r2, asl #2]
 200:../os_core/os_task.c ****             OS_EXIT_CRITICAL();
 2084              		.loc 1 200 0
 2085              	@ 200 "../os_core/os_task.c" 1
 2086 04e8 04009DE4 		ldmfd sp!, {r0}             
 2087 04ec 00F021E1 	msr   cpsr_c, r0              
 2088              	@ 0 "" 2
 2089              	.L21:
 201:../os_core/os_task.c ****         }
 202:../os_core/os_task.c ****         return (err);
 2090              		.loc 1 202 0
 2091 04f0 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2092 04f4 020000EA 		b	.L17
 2093              	.L19:
 203:../os_core/os_task.c ****     }
 204:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 2094              		.loc 1 204 0
 2095              	@ 204 "../os_core/os_task.c" 1
 2096 04f8 04009DE4 		ldmfd sp!, {r0}             
 2097 04fc 00F021E1 	msr   cpsr_c, r0              
 2098              	@ 0 "" 2
 205:../os_core/os_task.c ****     return (OS_PRIO_EXIST);
 2099              		.loc 1 205 0
 2100 0500 2830A0E3 		mov	r3, #40
 2101              	.L17:
 206:../os_core/os_task.c **** }
 2102              		.loc 1 206 0
 2103 0504 0300A0E1 		mov	r0, r3
 2104 0508 0CD04BE2 		sub	sp, fp, #12
 2105 050c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2106 0510 1EFF2FE1 		bx	lr
 2107              	.L23:
 2108              		.align	2
 2109              	.L22:
 2110 0514 00000000 		.word	OSIntNesting
 2111 0518 00000000 		.word	OSTCBPrioTbl
 2112 051c 00000000 		.word	OSRunning
 2113              		.cfi_endproc
 2114              	.LFE1:
 2116              		.align	2
 2117              		.global	OSTaskCreateExt
 2119              	OSTaskCreateExt:
 2120              	.LFB2:
 207:../os_core/os_task.c **** #endif
 208:../os_core/os_task.c **** /*$PAGE*/
 209:../os_core/os_task.c **** /*
 210:../os_core/os_task.c **** ***************************************************************************************************
 211:../os_core/os_task.c **** *                                     CREATE A TASK (Extended Version)
 212:../os_core/os_task.c **** *
 213:../os_core/os_task.c **** * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can ei
 214:../os_core/os_task.c **** *              be created prior to the start of multitasking or by a running task.  A task cannot b
 215:../os_core/os_task.c **** *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
 216:../os_core/os_task.c **** *              additional information about a task to be specified.
 217:../os_core/os_task.c **** *
 218:../os_core/os_task.c **** * Arguments  : task      is a pointer to the task's code
 219:../os_core/os_task.c **** *
 220:../os_core/os_task.c **** *              p_arg     is a pointer to an optional data area which can be used to pass parameters
 221:../os_core/os_task.c **** *                        the task when the task first executes.  Where the task is concerned it thi
 222:../os_core/os_task.c **** *                        it was invoked and passed the argument 'p_arg' as follows:
 223:../os_core/os_task.c **** *
 224:../os_core/os_task.c **** *                            void Task (void *p_arg)
 225:../os_core/os_task.c **** *                            {
 226:../os_core/os_task.c **** *                                for (;;) {
 227:../os_core/os_task.c **** *                                    Task code;
 228:../os_core/os_task.c **** *                                }
 229:../os_core/os_task.c **** *                            }
 230:../os_core/os_task.c **** *
 231:../os_core/os_task.c **** *              ptos      is a pointer to the task's top of stack.  If the configuration constant
 232:../os_core/os_task.c **** *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. fro
 233:../os_core/os_task.c **** *                        memory to low memory).  'ptos' will thus point to the highest (valid) memo
 234:../os_core/os_task.c **** *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to
 235:../os_core/os_task.c **** *                        lowest memory location of the stack and the stack will grow with increasin
 236:../os_core/os_task.c **** *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
 237:../os_core/os_task.c **** *
 238:../os_core/os_task.c **** *              prio      is the task's priority.  A unique priority MUST be assigned to each task a
 239:../os_core/os_task.c **** *                        lower the number, the higher the priority.
 240:../os_core/os_task.c **** *
 241:../os_core/os_task.c **** *              id        is the task's ID (0..65535)
 242:../os_core/os_task.c **** *
 243:../os_core/os_task.c **** *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
 244:../os_core/os_task.c **** *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. fro
 245:../os_core/os_task.c **** *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memor
 246:../os_core/os_task.c **** *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to
 247:../os_core/os_task.c **** *                        HIGHEST memory location of the stack and the stack will grow with increasi
 248:../os_core/os_task.c **** *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
 249:../os_core/os_task.c **** *
 250:../os_core/os_task.c **** *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U
 251:../os_core/os_task.c **** *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set
 252:../os_core/os_task.c **** *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Final
 253:../os_core/os_task.c **** *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
 254:../os_core/os_task.c **** *                        available on the stack.
 255:../os_core/os_task.c **** *
 256:../os_core/os_task.c **** *              pext      is a pointer to a user supplied memory location which is used as a TCB ext
 257:../os_core/os_task.c **** *                        For example, this user memory can hold the contents of floating-point regi
 258:../os_core/os_task.c **** *                        during a context switch, the time each task takes to execute, the number o
 259:../os_core/os_task.c **** *                        the task has been switched-in, etc.
 260:../os_core/os_task.c **** *
 261:../os_core/os_task.c **** *              opt       contains additional information (or options) about the behavior of the tas
 262:../os_core/os_task.c **** *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be applic
 263:../os_core/os_task.c **** *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
 264:../os_core/os_task.c **** *
 265:../os_core/os_task.c **** *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
 266:../os_core/os_task.c **** *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
 267:../os_core/os_task.c **** *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save the
 268:../os_core/os_task.c **** *                                                 during a context switch.
 269:../os_core/os_task.c **** *
 270:../os_core/os_task.c **** * Returns    : OS_NO_ERR               if the function was successful.
 271:../os_core/os_task.c **** *              OS_PRIO_EXIT            if the task priority already exist
 272:../os_core/os_task.c **** *                                      (each task MUST have a unique priority).
 273:../os_core/os_task.c **** *              OS_PRIO_INVALID         if the priority you specify is higher that the maximum allow
 274:../os_core/os_task.c **** *                                      (i.e. > OS_LOWEST_PRIO)
 275:../os_core/os_task.c **** *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
 276:../os_core/os_task.c **** ***************************************************************************************************
 277:../os_core/os_task.c **** */
 278:../os_core/os_task.c **** /*$PAGE*/
 279:../os_core/os_task.c **** #if OS_TASK_CREATE_EXT_EN > 0
 280:../os_core/os_task.c **** INT8U  OSTaskCreateExt (void   (*task)(void *pd),
 281:../os_core/os_task.c ****                         void    *p_arg,
 282:../os_core/os_task.c ****                         OS_STK  *ptos,
 283:../os_core/os_task.c ****                         INT8U    prio,
 284:../os_core/os_task.c ****                         INT16U   id,
 285:../os_core/os_task.c ****                         OS_STK  *pbos,
 286:../os_core/os_task.c ****                         INT32U   stk_size,
 287:../os_core/os_task.c ****                         void    *pext,
 288:../os_core/os_task.c ****                         INT16U   opt)
 289:../os_core/os_task.c **** {
 2121              		.loc 1 289 0
 2122              		.cfi_startproc
 2123              		@ Function supports interworking.
 2124              		@ args = 20, pretend = 0, frame = 24
 2125              		@ frame_needed = 1, uses_anonymous_args = 0
 2126 0520 0DC0A0E1 		mov	ip, sp
 2127              	.LCFI4:
 2128              		.cfi_def_cfa_register 12
 2129 0524 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2130 0528 04B04CE2 		sub	fp, ip, #4
 2131              		.cfi_offset 14, -8
 2132              		.cfi_offset 13, -12
 2133              		.cfi_offset 11, -16
 2134              	.LCFI5:
 2135              		.cfi_def_cfa 11, 4
 2136 052c 28D04DE2 		sub	sp, sp, #40
 2137 0530 18000BE5 		str	r0, [fp, #-24]
 2138 0534 1C100BE5 		str	r1, [fp, #-28]
 2139 0538 20200BE5 		str	r2, [fp, #-32]
 2140 053c 21304BE5 		strb	r3, [fp, #-33]
 290:../os_core/os_task.c ****     OS_STK    *psp;
 291:../os_core/os_task.c ****     INT8U      err;
 292:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register           
 293:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 294:../os_core/os_task.c **** 
 295:../os_core/os_task.c **** 
 296:../os_core/os_task.c **** 
 297:../os_core/os_task.c ****     cpu_sr = 0;                              /* Prevent compiler warning                           
 298:../os_core/os_task.c **** #endif    
 299:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 300:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range       
 2141              		.loc 1 300 0
 2142 0540 21305BE5 		ldrb	r3, [fp, #-33]	@ zero_extendqisi2
 2143 0544 3F0053E3 		cmp	r3, #63
 2144 0548 0100009A 		bls	.L25
 301:../os_core/os_task.c ****         return (OS_PRIO_INVALID);
 2145              		.loc 1 301 0
 2146 054c 2A30A0E3 		mov	r3, #42
 2147 0550 470000EA 		b	.L26
 2148              	.L25:
 302:../os_core/os_task.c ****     }
 303:../os_core/os_task.c **** #endif
 304:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2149              		.loc 1 304 0
 2150              	@ 304 "../os_core/os_task.c" 1
 2151 0554 00000FE1 		mrs   r0, cpsr              
 2152 0558 04002DE5 	stmfd sp!, {r0}             
 2153 055c C00080E3 	orr   r0, r0, #0b11000000   
 2154 0560 00F021E1 	msr   cpsr_c, r0              
 2155              	@ 0 "" 2
 305:../os_core/os_task.c ****     if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an I
 2156              		.loc 1 305 0
 2157 0564 18319FE5 		ldr	r3, .L31
 2158 0568 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2159 056c 000053E3 		cmp	r3, #0
 2160 0570 0300000A 		beq	.L27
 306:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2161              		.loc 1 306 0
 2162              	@ 306 "../os_core/os_task.c" 1
 2163 0574 04009DE4 		ldmfd sp!, {r0}             
 2164 0578 00F021E1 	msr   cpsr_c, r0              
 2165              	@ 0 "" 2
 307:../os_core/os_task.c ****         return (OS_ERR_TASK_CREATE_ISR);
 2166              		.loc 1 307 0
 2167 057c 1030A0E3 		mov	r3, #16
 2168 0580 3B0000EA 		b	.L26
 2169              	.L27:
 308:../os_core/os_task.c ****     }
 309:../os_core/os_task.c ****     if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priori
 2170              		.loc 1 309 0
 2171 0584 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2172 0588 F8309FE5 		ldr	r3, .L31+4
 2173 058c 023193E7 		ldr	r3, [r3, r2, asl #2]
 2174 0590 000053E3 		cmp	r3, #0
 2175 0594 3300001A 		bne	.L28
 310:../os_core/os_task.c ****         OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing .
 2176              		.loc 1 310 0
 2177 0598 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2178 059c E4309FE5 		ldr	r3, .L31+4
 2179 05a0 0110A0E3 		mov	r1, #1
 2180 05a4 021183E7 		str	r1, [r3, r2, asl #2]
 311:../os_core/os_task.c ****                                              /* ... the same thing until task is created.          
 312:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2181              		.loc 1 312 0
 2182              	@ 312 "../os_core/os_task.c" 1
 2183 05a8 04009DE4 		ldmfd sp!, {r0}             
 2184 05ac 00F021E1 	msr   cpsr_c, r0              
 2185              	@ 0 "" 2
 313:../os_core/os_task.c **** 
 314:../os_core/os_task.c ****         OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed) 
 2186              		.loc 1 314 0
 2187 05b0 B431DBE1 		ldrh	r3, [fp, #20]
 2188 05b4 08009BE5 		ldr	r0, [fp, #8]
 2189 05b8 0C109BE5 		ldr	r1, [fp, #12]
 2190 05bc 0320A0E1 		mov	r2, r3
 2191 05c0 FEFFFFEB 		bl	OS_TaskStkClr
 315:../os_core/os_task.c **** 
 316:../os_core/os_task.c ****         psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack      
 2192              		.loc 1 316 0
 2193 05c4 B431DBE1 		ldrh	r3, [fp, #20]
 2194 05c8 18001BE5 		ldr	r0, [fp, #-24]
 2195 05cc 1C101BE5 		ldr	r1, [fp, #-28]
 2196 05d0 20201BE5 		ldr	r2, [fp, #-32]
 2197 05d4 FEFFFFEB 		bl	OSTaskStkInit
 2198 05d8 10000BE5 		str	r0, [fp, #-16]
 317:../os_core/os_task.c ****         err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 2199              		.loc 1 317 0
 2200 05dc 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2201 05e0 B430DBE1 		ldrh	r3, [fp, #4]
 2202 05e4 0C109BE5 		ldr	r1, [fp, #12]
 2203 05e8 00108DE5 		str	r1, [sp, #0]
 2204 05ec 10109BE5 		ldr	r1, [fp, #16]
 2205 05f0 04108DE5 		str	r1, [sp, #4]
 2206 05f4 B411DBE1 		ldrh	r1, [fp, #20]
 2207 05f8 08108DE5 		str	r1, [sp, #8]
 2208 05fc 0200A0E1 		mov	r0, r2
 2209 0600 10101BE5 		ldr	r1, [fp, #-16]
 2210 0604 08209BE5 		ldr	r2, [fp, #8]
 2211 0608 FEFFFFEB 		bl	OS_TCBInit
 2212 060c 0030A0E1 		mov	r3, r0
 2213 0610 11304BE5 		strb	r3, [fp, #-17]
 318:../os_core/os_task.c ****         if (err == OS_NO_ERR) {
 2214              		.loc 1 318 0
 2215 0614 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2216 0618 000053E3 		cmp	r3, #0
 2217 061c 0500001A 		bne	.L29
 319:../os_core/os_task.c ****             if (OSRunning == TRUE) {                           /* Find HPT if multitasking has star
 2218              		.loc 1 319 0
 2219 0620 64309FE5 		ldr	r3, .L31+8
 2220 0624 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2221 0628 010053E3 		cmp	r3, #1
 2222 062c 0B00001A 		bne	.L30
 320:../os_core/os_task.c ****                 OS_Sched();
 2223              		.loc 1 320 0
 2224 0630 FEFFFFEB 		bl	OS_Sched
 2225 0634 090000EA 		b	.L30
 2226              	.L29:
 321:../os_core/os_task.c ****             }
 322:../os_core/os_task.c ****         } else {
 323:../os_core/os_task.c ****             OS_ENTER_CRITICAL();
 2227              		.loc 1 323 0
 2228              	@ 323 "../os_core/os_task.c" 1
 2229 0638 00000FE1 		mrs   r0, cpsr              
 2230 063c 04002DE5 	stmfd sp!, {r0}             
 2231 0640 C00080E3 	orr   r0, r0, #0b11000000   
 2232 0644 00F021E1 	msr   cpsr_c, r0              
 2233              	@ 0 "" 2
 324:../os_core/os_task.c ****             OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to othe
 2234              		.loc 1 324 0
 2235 0648 21205BE5 		ldrb	r2, [fp, #-33]	@ zero_extendqisi2
 2236 064c 34309FE5 		ldr	r3, .L31+4
 2237 0650 0010A0E3 		mov	r1, #0
 2238 0654 021183E7 		str	r1, [r3, r2, asl #2]
 325:../os_core/os_task.c ****             OS_EXIT_CRITICAL();
 2239              		.loc 1 325 0
 2240              	@ 325 "../os_core/os_task.c" 1
 2241 0658 04009DE4 		ldmfd sp!, {r0}             
 2242 065c 00F021E1 	msr   cpsr_c, r0              
 2243              	@ 0 "" 2
 2244              	.L30:
 326:../os_core/os_task.c ****         }
 327:../os_core/os_task.c ****         return (err);
 2245              		.loc 1 327 0
 2246 0660 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2247 0664 020000EA 		b	.L26
 2248              	.L28:
 328:../os_core/os_task.c ****     }
 329:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 2249              		.loc 1 329 0
 2250              	@ 329 "../os_core/os_task.c" 1
 2251 0668 04009DE4 		ldmfd sp!, {r0}             
 2252 066c 00F021E1 	msr   cpsr_c, r0              
 2253              	@ 0 "" 2
 330:../os_core/os_task.c ****     return (OS_PRIO_EXIST);
 2254              		.loc 1 330 0
 2255 0670 2830A0E3 		mov	r3, #40
 2256              	.L26:
 331:../os_core/os_task.c **** }
 2257              		.loc 1 331 0
 2258 0674 0300A0E1 		mov	r0, r3
 2259 0678 0CD04BE2 		sub	sp, fp, #12
 2260 067c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2261 0680 1EFF2FE1 		bx	lr
 2262              	.L32:
 2263              		.align	2
 2264              	.L31:
 2265 0684 00000000 		.word	OSIntNesting
 2266 0688 00000000 		.word	OSTCBPrioTbl
 2267 068c 00000000 		.word	OSRunning
 2268              		.cfi_endproc
 2269              	.LFE2:
 2271              		.align	2
 2272              		.global	OSTaskDel
 2274              	OSTaskDel:
 2275              	.LFB3:
 332:../os_core/os_task.c **** #endif
 333:../os_core/os_task.c **** /*$PAGE*/
 334:../os_core/os_task.c **** /*
 335:../os_core/os_task.c **** ***************************************************************************************************
 336:../os_core/os_task.c **** *                                            DELETE A TASK
 337:../os_core/os_task.c **** *
 338:../os_core/os_task.c **** * Description: This function allows you to delete a task.  The calling task can delete itself by
 339:../os_core/os_task.c **** *              its own priority number.  The deleted task is returned to the dormant state and can 
 340:../os_core/os_task.c **** *              re-activated by creating the deleted task again.
 341:../os_core/os_task.c **** *
 342:../os_core/os_task.c **** * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
 343:../os_core/os_task.c **** *                      the current task without knowing its priority level by setting 'prio' to
 344:../os_core/os_task.c **** *                      OS_PRIO_SELF.
 345:../os_core/os_task.c **** *
 346:../os_core/os_task.c **** * Returns    : OS_NO_ERR           if the call is successful
 347:../os_core/os_task.c **** *              OS_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
 348:../os_core/os_task.c **** *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
 349:../os_core/os_task.c **** *                                  (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF
 350:../os_core/os_task.c **** *              OS_TASK_DEL_ERR     if the task you want to delete does not exist.
 351:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST   if the task is assigned to a Mutex PIP.
 352:../os_core/os_task.c **** *              OS_TASK_DEL_ISR     if you tried to delete a task from an ISR
 353:../os_core/os_task.c **** *
 354:../os_core/os_task.c **** * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
 355:../os_core/os_task.c **** *                    a) by making it not ready
 356:../os_core/os_task.c **** *                    b) by removing it from any wait lists
 357:../os_core/os_task.c **** *                    c) by preventing OSTimeTick() from making the task ready to run.
 358:../os_core/os_task.c **** *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
 359:../os_core/os_task.c **** *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most proce
 360:../os_core/os_task.c **** *                 the next instruction following the enable interrupt instruction is ignored.  
 361:../os_core/os_task.c **** *              3) An ISR cannot delete a task.
 362:../os_core/os_task.c **** *              4) The lock nesting counter is incremented because, for a brief instant, if the curr
 363:../os_core/os_task.c **** *                 task is being deleted, the current task would not be able to be rescheduled becau
 364:../os_core/os_task.c **** *                 is removed from the ready list.  Incrementing the nesting counter prevents anothe
 365:../os_core/os_task.c **** *                 from being schedule.  This means that an ISR would return to the current task whi
 366:../os_core/os_task.c **** *                 being deleted.  The rest of the deletion would thus be able to be completed.
 367:../os_core/os_task.c **** ***************************************************************************************************
 368:../os_core/os_task.c **** */
 369:../os_core/os_task.c **** /*$PAGE*/
 370:../os_core/os_task.c **** #if OS_TASK_DEL_EN > 0
 371:../os_core/os_task.c **** INT8U  OSTaskDel (INT8U prio)
 372:../os_core/os_task.c **** {
 2276              		.loc 1 372 0
 2277              		.cfi_startproc
 2278              		@ Function supports interworking.
 2279              		@ args = 0, pretend = 0, frame = 24
 2280              		@ frame_needed = 1, uses_anonymous_args = 0
 2281 0690 0DC0A0E1 		mov	ip, sp
 2282              	.LCFI6:
 2283              		.cfi_def_cfa_register 12
 2284 0694 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2285 0698 04B04CE2 		sub	fp, ip, #4
 2286              		.cfi_offset 14, -8
 2287              		.cfi_offset 13, -12
 2288              		.cfi_offset 11, -16
 2289              	.LCFI7:
 2290              		.cfi_def_cfa 11, 4
 2291 069c 18D04DE2 		sub	sp, sp, #24
 2292 06a0 0030A0E1 		mov	r3, r0
 2293 06a4 1D304BE5 		strb	r3, [fp, #-29]
 373:../os_core/os_task.c **** #if OS_EVENT_EN
 374:../os_core/os_task.c ****     OS_EVENT     *pevent;
 375:../os_core/os_task.c **** #endif    
 376:../os_core/os_task.c **** #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
 377:../os_core/os_task.c ****     OS_FLAG_NODE *pnode;
 378:../os_core/os_task.c **** #endif
 379:../os_core/os_task.c ****     OS_TCB       *ptcb;
 380:../os_core/os_task.c **** 	INT8U         y;
 381:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 382:../os_core/os_task.c ****     OS_CPU_SR     cpu_sr;
 383:../os_core/os_task.c **** 
 384:../os_core/os_task.c **** 
 385:../os_core/os_task.c **** 
 386:../os_core/os_task.c ****     cpu_sr = 0;                                                 /* Prevent compiler warning        
 387:../os_core/os_task.c **** #endif    
 388:../os_core/os_task.c ****     if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR
 2294              		.loc 1 388 0
 2295 06a8 98339FE5 		ldr	r3, .L48
 2296 06ac 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2297 06b0 000053E3 		cmp	r3, #0
 2298 06b4 0100000A 		beq	.L34
 389:../os_core/os_task.c ****         return (OS_TASK_DEL_ISR);
 2299              		.loc 1 389 0
 2300 06b8 3F30A0E3 		mov	r3, #63
 2301 06bc DD0000EA 		b	.L35
 2302              	.L34:
 390:../os_core/os_task.c ****     }
 391:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 392:../os_core/os_task.c ****     if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task 
 2303              		.loc 1 392 0
 2304 06c0 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 2305 06c4 3F0053E3 		cmp	r3, #63
 2306 06c8 0100001A 		bne	.L36
 393:../os_core/os_task.c ****         return (OS_TASK_DEL_IDLE);
 2307              		.loc 1 393 0
 2308 06cc 3D30A0E3 		mov	r3, #61
 2309 06d0 D80000EA 		b	.L35
 2310              	.L36:
 394:../os_core/os_task.c ****     }
 395:../os_core/os_task.c ****     if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?           
 2311              		.loc 1 395 0
 2312 06d4 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 2313 06d8 3E0053E3 		cmp	r3, #62
 2314 06dc 0400009A 		bls	.L37
 396:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {       
 2315              		.loc 1 396 0
 2316 06e0 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 2317 06e4 FF0053E3 		cmp	r3, #255
 2318 06e8 0100000A 		beq	.L37
 397:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 2319              		.loc 1 397 0
 2320 06ec 2A30A0E3 		mov	r3, #42
 2321 06f0 D00000EA 		b	.L35
 2322              	.L37:
 398:../os_core/os_task.c ****         }
 399:../os_core/os_task.c ****     }
 400:../os_core/os_task.c **** #endif
 401:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2323              		.loc 1 401 0
 2324              	@ 401 "../os_core/os_task.c" 1
 2325 06f4 00000FE1 		mrs   r0, cpsr              
 2326 06f8 04002DE5 	stmfd sp!, {r0}             
 2327 06fc C00080E3 	orr   r0, r0, #0b11000000   
 2328 0700 00F021E1 	msr   cpsr_c, r0              
 2329              	@ 0 "" 2
 402:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self
 2330              		.loc 1 402 0
 2331 0704 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 2332 0708 FF0053E3 		cmp	r3, #255
 2333 070c 0300001A 		bne	.L38
 403:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to curren
 2334              		.loc 1 403 0
 2335 0710 34339FE5 		ldr	r3, .L48+4
 2336 0714 003093E5 		ldr	r3, [r3, #0]
 2337 0718 2E30D3E5 		ldrb	r3, [r3, #46]
 2338 071c 1D304BE5 		strb	r3, [fp, #-29]
 2339              	.L38:
 404:../os_core/os_task.c ****     }
 405:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 2340              		.loc 1 405 0
 2341 0720 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 2342 0724 24339FE5 		ldr	r3, .L48+8
 2343 0728 023193E7 		ldr	r3, [r3, r2, asl #2]
 2344 072c 10300BE5 		str	r3, [fp, #-16]
 406:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist       
 2345              		.loc 1 406 0
 2346 0730 10301BE5 		ldr	r3, [fp, #-16]
 2347 0734 000053E3 		cmp	r3, #0
 2348 0738 0300001A 		bne	.L39
 407:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2349              		.loc 1 407 0
 2350              	@ 407 "../os_core/os_task.c" 1
 2351 073c 04009DE4 		ldmfd sp!, {r0}             
 2352 0740 00F021E1 	msr   cpsr_c, r0              
 2353              	@ 0 "" 2
 408:../os_core/os_task.c ****         return (OS_TASK_DEL_ERR);
 2354              		.loc 1 408 0
 2355 0744 3C30A0E3 		mov	r3, #60
 2356 0748 BA0000EA 		b	.L35
 2357              	.L39:
 409:../os_core/os_task.c ****     }
 410:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                                  /* Must not be assigned to Mutex   
 2358              		.loc 1 410 0
 2359 074c 10301BE5 		ldr	r3, [fp, #-16]
 2360 0750 010053E3 		cmp	r3, #1
 2361 0754 0300001A 		bne	.L40
 411:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2362              		.loc 1 411 0
 2363              	@ 411 "../os_core/os_task.c" 1
 2364 0758 04009DE4 		ldmfd sp!, {r0}             
 2365 075c 00F021E1 	msr   cpsr_c, r0              
 2366              	@ 0 "" 2
 412:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 2367              		.loc 1 412 0
 2368 0760 0B30A0E3 		mov	r3, #11
 2369 0764 B30000EA 		b	.L35
 2370              	.L40:
 413:../os_core/os_task.c ****     }
 414:../os_core/os_task.c **** 	y            =  ptcb->OSTCBY;
 2371              		.loc 1 414 0
 2372 0768 10301BE5 		ldr	r3, [fp, #-16]
 2373 076c 3030D3E5 		ldrb	r3, [r3, #48]
 2374 0770 11304BE5 		strb	r3, [fp, #-17]
 415:../os_core/os_task.c **** 	OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
 2375              		.loc 1 415 0
 2376 0774 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2377 0778 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 2378 077c D0129FE5 		ldr	r1, .L48+12
 2379 0780 0220D1E7 		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 2380 0784 FF1002E2 		and	r1, r2, #255
 2381 0788 10201BE5 		ldr	r2, [fp, #-16]
 2382 078c 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 2383 0790 FF2002E2 		and	r2, r2, #255
 2384 0794 0220E0E1 		mvn	r2, r2
 2385 0798 FF2002E2 		and	r2, r2, #255
 2386 079c 022001E0 		and	r2, r1, r2
 2387 07a0 FF2002E2 		and	r2, r2, #255
 2388 07a4 FF1002E2 		and	r1, r2, #255
 2389 07a8 A4229FE5 		ldr	r2, .L48+12
 2390 07ac 0310C2E7 		strb	r1, [r2, r3]
 416:../os_core/os_task.c ****     if (OSRdyTbl[y] == 0x00) {                                  /* Make task not ready             
 2391              		.loc 1 416 0
 2392 07b0 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2393 07b4 98229FE5 		ldr	r2, .L48+12
 2394 07b8 0330D2E7 		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 2395 07bc 000053E3 		cmp	r3, #0
 2396 07c0 0C00001A 		bne	.L41
 417:../os_core/os_task.c ****         OSRdyGrp &= ~ptcb->OSTCBBitY;
 2397              		.loc 1 417 0
 2398 07c4 10301BE5 		ldr	r3, [fp, #-16]
 2399 07c8 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 2400 07cc FF3003E2 		and	r3, r3, #255
 2401 07d0 0330E0E1 		mvn	r3, r3
 2402 07d4 FF2003E2 		and	r2, r3, #255
 2403 07d8 78329FE5 		ldr	r3, .L48+16
 2404 07dc 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2405 07e0 FF3003E2 		and	r3, r3, #255
 2406 07e4 033002E0 		and	r3, r2, r3
 2407 07e8 FF3003E2 		and	r3, r3, #255
 2408 07ec FF2003E2 		and	r2, r3, #255
 2409 07f0 60329FE5 		ldr	r3, .L48+16
 2410 07f4 0020C3E5 		strb	r2, [r3, #0]
 2411              	.L41:
 418:../os_core/os_task.c ****     }
 419:../os_core/os_task.c **** #if OS_EVENT_EN
 420:../os_core/os_task.c ****     pevent = ptcb->OSTCBEventPtr;
 2412              		.loc 1 420 0
 2413 07f8 10301BE5 		ldr	r3, [fp, #-16]
 2414 07fc 1C3093E5 		ldr	r3, [r3, #28]
 2415 0800 18300BE5 		str	r3, [fp, #-24]
 421:../os_core/os_task.c ****     if (pevent != (OS_EVENT *)0) {                              /* If task is waiting on event     
 2416              		.loc 1 421 0
 2417 0804 18301BE5 		ldr	r3, [fp, #-24]
 2418 0808 000053E3 		cmp	r3, #0
 2419 080c 2900000A 		beq	.L42
 422:../os_core/os_task.c **** 	    pevent->OSEventTbl[y] &= ~ptcb->OSTCBBitX;
 2420              		.loc 1 422 0
 2421 0810 11105BE5 		ldrb	r1, [fp, #-17]	@ zero_extendqisi2
 2422 0814 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 2423 0818 18001BE5 		ldr	r0, [fp, #-24]
 2424 081c 0830A0E3 		mov	r3, #8
 2425 0820 022080E0 		add	r2, r0, r2
 2426 0824 033082E0 		add	r3, r2, r3
 2427 0828 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2428 082c FF2003E2 		and	r2, r3, #255
 2429 0830 10301BE5 		ldr	r3, [fp, #-16]
 2430 0834 3130D3E5 		ldrb	r3, [r3, #49]	@ zero_extendqisi2
 2431 0838 FF3003E2 		and	r3, r3, #255
 2432 083c 0330E0E1 		mvn	r3, r3
 2433 0840 FF3003E2 		and	r3, r3, #255
 2434 0844 033002E0 		and	r3, r2, r3
 2435 0848 FF3003E2 		and	r3, r3, #255
 2436 084c FF2003E2 		and	r2, r3, #255
 2437 0850 18001BE5 		ldr	r0, [fp, #-24]
 2438 0854 0830A0E3 		mov	r3, #8
 2439 0858 011080E0 		add	r1, r0, r1
 2440 085c 033081E0 		add	r3, r1, r3
 2441 0860 0020C3E5 		strb	r2, [r3, #0]
 423:../os_core/os_task.c ****         if (pevent->OSEventTbl[y] == 0) {                       /* ... remove task from ...        
 2442              		.loc 1 423 0
 2443 0864 11205BE5 		ldrb	r2, [fp, #-17]	@ zero_extendqisi2
 2444 0868 18101BE5 		ldr	r1, [fp, #-24]
 2445 086c 0830A0E3 		mov	r3, #8
 2446 0870 022081E0 		add	r2, r1, r2
 2447 0874 033082E0 		add	r3, r2, r3
 2448 0878 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2449 087c 000053E3 		cmp	r3, #0
 2450 0880 0C00001A 		bne	.L42
 424:../os_core/os_task.c ****             pevent->OSEventGrp &= ~ptcb->OSTCBBitY;             /* ... event ctrl block            
 2451              		.loc 1 424 0
 2452 0884 18301BE5 		ldr	r3, [fp, #-24]
 2453 0888 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2454 088c FF2003E2 		and	r2, r3, #255
 2455 0890 10301BE5 		ldr	r3, [fp, #-16]
 2456 0894 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 2457 0898 FF3003E2 		and	r3, r3, #255
 2458 089c 0330E0E1 		mvn	r3, r3
 2459 08a0 FF3003E2 		and	r3, r3, #255
 2460 08a4 033002E0 		and	r3, r2, r3
 2461 08a8 FF3003E2 		and	r3, r3, #255
 2462 08ac FF2003E2 		and	r2, r3, #255
 2463 08b0 18301BE5 		ldr	r3, [fp, #-24]
 2464 08b4 0120C3E5 		strb	r2, [r3, #1]
 2465              	.L42:
 425:../os_core/os_task.c ****         }
 426:../os_core/os_task.c ****     }
 427:../os_core/os_task.c **** #endif
 428:../os_core/os_task.c **** #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
 429:../os_core/os_task.c ****     pnode = ptcb->OSTCBFlagNode;
 2466              		.loc 1 429 0
 2467 08b8 10301BE5 		ldr	r3, [fp, #-16]
 2468 08bc 243093E5 		ldr	r3, [r3, #36]
 2469 08c0 1C300BE5 		str	r3, [fp, #-28]
 430:../os_core/os_task.c ****     if (pnode != (OS_FLAG_NODE *)0) {                           /* If task is waiting on event flag
 2470              		.loc 1 430 0
 2471 08c4 1C301BE5 		ldr	r3, [fp, #-28]
 2472 08c8 000053E3 		cmp	r3, #0
 2473 08cc 0100000A 		beq	.L43
 431:../os_core/os_task.c ****         OS_FlagUnlink(pnode);                                   /* Remove from wait list           
 2474              		.loc 1 431 0
 2475 08d0 1C001BE5 		ldr	r0, [fp, #-28]
 2476 08d4 FEFFFFEB 		bl	OS_FlagUnlink
 2477              	.L43:
 432:../os_core/os_task.c ****     }
 433:../os_core/os_task.c **** #endif
 434:../os_core/os_task.c ****     ptcb->OSTCBDly    = 0;                                      /* Prevent OSTimeTick() from updati
 2478              		.loc 1 434 0
 2479 08d8 10301BE5 		ldr	r3, [fp, #-16]
 2480 08dc 0020A0E3 		mov	r2, #0
 2481 08e0 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
 435:../os_core/os_task.c ****     ptcb->OSTCBStat   = OS_STAT_RDY;                            /* Prevent task from being resumed 
 2482              		.loc 1 435 0
 2483 08e4 10301BE5 		ldr	r3, [fp, #-16]
 2484 08e8 0020A0E3 		mov	r2, #0
 2485 08ec 2C20C3E5 		strb	r2, [r3, #44]
 436:../os_core/os_task.c ****     ptcb->OSTCBPendTO = FALSE;
 2486              		.loc 1 436 0
 2487 08f0 10301BE5 		ldr	r3, [fp, #-16]
 2488 08f4 0020A0E3 		mov	r2, #0
 2489 08f8 2D20C3E5 		strb	r2, [r3, #45]
 437:../os_core/os_task.c **** 	if (OSLockNesting < 255u) {                                 /* Make sure we don't context switch  
 2490              		.loc 1 437 0
 2491 08fc 58319FE5 		ldr	r3, .L48+20
 2492 0900 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2493 0904 FF0053E3 		cmp	r3, #255
 2494 0908 0500000A 		beq	.L44
 438:../os_core/os_task.c ****         OSLockNesting++;
 2495              		.loc 1 438 0
 2496 090c 48319FE5 		ldr	r3, .L48+20
 2497 0910 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2498 0914 013083E2 		add	r3, r3, #1
 2499 0918 FF2003E2 		and	r2, r3, #255
 2500 091c 38319FE5 		ldr	r3, .L48+20
 2501 0920 0020C3E5 		strb	r2, [r3, #0]
 2502              	.L44:
 439:../os_core/os_task.c **** 	}
 440:../os_core/os_task.c ****     OS_EXIT_CRITICAL();                                         /* Enabling INT. ignores next instr
 2503              		.loc 1 440 0
 2504              	@ 440 "../os_core/os_task.c" 1
 2505 0924 04009DE4 		ldmfd sp!, {r0}             
 2506 0928 00F021E1 	msr   cpsr_c, r0              
 2507              	@ 0 "" 2
 441:../os_core/os_task.c ****     OS_Dummy();                                                 /* ... Dummy ensures that INTs will
 2508              		.loc 1 441 0
 2509 092c FEFFFFEB 		bl	OS_Dummy
 442:../os_core/os_task.c ****     OS_ENTER_CRITICAL();                                        /* ... disabled HERE!              
 2510              		.loc 1 442 0
 2511              	@ 442 "../os_core/os_task.c" 1
 2512 0930 00000FE1 		mrs   r0, cpsr              
 2513 0934 04002DE5 	stmfd sp!, {r0}             
 2514 0938 C00080E3 	orr   r0, r0, #0b11000000   
 2515 093c 00F021E1 	msr   cpsr_c, r0              
 2516              	@ 0 "" 2
 443:../os_core/os_task.c **** 	if (OSLockNesting > 0) {                                    /* Remove context switch lock         
 2517              		.loc 1 443 0
 2518 0940 14319FE5 		ldr	r3, .L48+20
 2519 0944 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2520 0948 000053E3 		cmp	r3, #0
 2521 094c 0500000A 		beq	.L45
 444:../os_core/os_task.c ****         OSLockNesting--;
 2522              		.loc 1 444 0
 2523 0950 04319FE5 		ldr	r3, .L48+20
 2524 0954 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2525 0958 013043E2 		sub	r3, r3, #1
 2526 095c FF2003E2 		and	r2, r3, #255
 2527 0960 F4309FE5 		ldr	r3, .L48+20
 2528 0964 0020C3E5 		strb	r2, [r3, #0]
 2529              	.L45:
 445:../os_core/os_task.c **** 	}
 446:../os_core/os_task.c ****     OSTaskDelHook(ptcb);                                        /* Call user defined hook          
 2530              		.loc 1 446 0
 2531 0968 10001BE5 		ldr	r0, [fp, #-16]
 2532 096c FEFFFFEB 		bl	OSTaskDelHook
 447:../os_core/os_task.c ****     OSTaskCtr--;                                                /* One less task being managed     
 2533              		.loc 1 447 0
 2534 0970 E8309FE5 		ldr	r3, .L48+24
 2535 0974 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2536 0978 013043E2 		sub	r3, r3, #1
 2537 097c FF2003E2 		and	r2, r3, #255
 2538 0980 D8309FE5 		ldr	r3, .L48+24
 2539 0984 0020C3E5 		strb	r2, [r3, #0]
 448:../os_core/os_task.c ****     OSTCBPrioTbl[prio] = (OS_TCB *)0;                           /* Clear old priority entry        
 2540              		.loc 1 448 0
 2541 0988 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 2542 098c BC309FE5 		ldr	r3, .L48+8
 2543 0990 0010A0E3 		mov	r1, #0
 2544 0994 021183E7 		str	r1, [r3, r2, asl #2]
 449:../os_core/os_task.c ****     if (ptcb->OSTCBPrev == (OS_TCB *)0) {                       /* Remove from TCB chain           
 2545              		.loc 1 449 0
 2546 0998 10301BE5 		ldr	r3, [fp, #-16]
 2547 099c 183093E5 		ldr	r3, [r3, #24]
 2548 09a0 000053E3 		cmp	r3, #0
 2549 09a4 0800001A 		bne	.L46
 450:../os_core/os_task.c ****         ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 2550              		.loc 1 450 0
 2551 09a8 10301BE5 		ldr	r3, [fp, #-16]
 2552 09ac 143093E5 		ldr	r3, [r3, #20]
 2553 09b0 0020A0E3 		mov	r2, #0
 2554 09b4 182083E5 		str	r2, [r3, #24]
 451:../os_core/os_task.c ****         OSTCBList                  = ptcb->OSTCBNext;
 2555              		.loc 1 451 0
 2556 09b8 10301BE5 		ldr	r3, [fp, #-16]
 2557 09bc 142093E5 		ldr	r2, [r3, #20]
 2558 09c0 9C309FE5 		ldr	r3, .L48+28
 2559 09c4 002083E5 		str	r2, [r3, #0]
 2560 09c8 090000EA 		b	.L47
 2561              	.L46:
 452:../os_core/os_task.c ****     } else {
 453:../os_core/os_task.c ****         ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 2562              		.loc 1 453 0
 2563 09cc 10301BE5 		ldr	r3, [fp, #-16]
 2564 09d0 183093E5 		ldr	r3, [r3, #24]
 2565 09d4 10201BE5 		ldr	r2, [fp, #-16]
 2566 09d8 142092E5 		ldr	r2, [r2, #20]
 2567 09dc 142083E5 		str	r2, [r3, #20]
 454:../os_core/os_task.c ****         ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 2568              		.loc 1 454 0
 2569 09e0 10301BE5 		ldr	r3, [fp, #-16]
 2570 09e4 143093E5 		ldr	r3, [r3, #20]
 2571 09e8 10201BE5 		ldr	r2, [fp, #-16]
 2572 09ec 182092E5 		ldr	r2, [r2, #24]
 2573 09f0 182083E5 		str	r2, [r3, #24]
 2574              	.L47:
 455:../os_core/os_task.c ****     }
 456:../os_core/os_task.c ****     ptcb->OSTCBNext   = OSTCBFreeList;                          /* Return TCB to free TCB list     
 2575              		.loc 1 456 0
 2576 09f4 6C309FE5 		ldr	r3, .L48+32
 2577 09f8 002093E5 		ldr	r2, [r3, #0]
 2578 09fc 10301BE5 		ldr	r3, [fp, #-16]
 2579 0a00 142083E5 		str	r2, [r3, #20]
 457:../os_core/os_task.c ****     OSTCBFreeList     = ptcb;
 2580              		.loc 1 457 0
 2581 0a04 5C309FE5 		ldr	r3, .L48+32
 2582 0a08 10201BE5 		ldr	r2, [fp, #-16]
 2583 0a0c 002083E5 		str	r2, [r3, #0]
 458:../os_core/os_task.c **** #if OS_TASK_NAME_SIZE > 1
 459:../os_core/os_task.c ****     ptcb->OSTCBTaskName[0] = '?';                               /* Unknown name                    
 2584              		.loc 1 459 0
 2585 0a10 10301BE5 		ldr	r3, [fp, #-16]
 2586 0a14 3F20A0E3 		mov	r2, #63
 2587 0a18 4820C3E5 		strb	r2, [r3, #72]
 460:../os_core/os_task.c ****     ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 2588              		.loc 1 460 0
 2589 0a1c 10301BE5 		ldr	r3, [fp, #-16]
 2590 0a20 0020A0E3 		mov	r2, #0
 2591 0a24 4920C3E5 		strb	r2, [r3, #73]
 461:../os_core/os_task.c **** #endif
 462:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 2592              		.loc 1 462 0
 2593              	@ 462 "../os_core/os_task.c" 1
 2594 0a28 04009DE4 		ldmfd sp!, {r0}             
 2595 0a2c 00F021E1 	msr   cpsr_c, r0              
 2596              	@ 0 "" 2
 463:../os_core/os_task.c ****     OS_Sched();                                                 /* Find new highest priority task  
 2597              		.loc 1 463 0
 2598 0a30 FEFFFFEB 		bl	OS_Sched
 464:../os_core/os_task.c ****     return (OS_NO_ERR);
 2599              		.loc 1 464 0
 2600 0a34 0030A0E3 		mov	r3, #0
 2601              	.L35:
 465:../os_core/os_task.c **** }
 2602              		.loc 1 465 0
 2603 0a38 0300A0E1 		mov	r0, r3
 2604 0a3c 0CD04BE2 		sub	sp, fp, #12
 2605 0a40 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2606 0a44 1EFF2FE1 		bx	lr
 2607              	.L49:
 2608              		.align	2
 2609              	.L48:
 2610 0a48 00000000 		.word	OSIntNesting
 2611 0a4c 00000000 		.word	OSTCBCur
 2612 0a50 00000000 		.word	OSTCBPrioTbl
 2613 0a54 00000000 		.word	OSRdyTbl
 2614 0a58 00000000 		.word	OSRdyGrp
 2615 0a5c 00000000 		.word	OSLockNesting
 2616 0a60 00000000 		.word	OSTaskCtr
 2617 0a64 00000000 		.word	OSTCBList
 2618 0a68 00000000 		.word	OSTCBFreeList
 2619              		.cfi_endproc
 2620              	.LFE3:
 2622              		.align	2
 2623              		.global	OSTaskDelReq
 2625              	OSTaskDelReq:
 2626              	.LFB4:
 466:../os_core/os_task.c **** #endif
 467:../os_core/os_task.c **** /*$PAGE*/
 468:../os_core/os_task.c **** /*
 469:../os_core/os_task.c **** ***************************************************************************************************
 470:../os_core/os_task.c **** *                                    REQUEST THAT A TASK DELETE ITSELF
 471:../os_core/os_task.c **** *
 472:../os_core/os_task.c **** * Description: This function is used to:
 473:../os_core/os_task.c **** *                   a) notify a task to delete itself.
 474:../os_core/os_task.c **** *                   b) to see if a task requested that the current task delete itself.
 475:../os_core/os_task.c **** *              This function is a little tricky to understand.  Basically, you have a task that nee
 476:../os_core/os_task.c **** *              to be deleted however, this task has resources that it has allocated (memory buffers
 477:../os_core/os_task.c **** *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
 478:../os_core/os_task.c **** *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate 
 479:../os_core/os_task.c **** *              the task needs to be deleted.  Deleting of the task is however, deferred to the task
 480:../os_core/os_task.c **** *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting
 481:../os_core/os_task.c **** *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it ca
 482:../os_core/os_task.c **** *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the re
 483:../os_core/os_task.c **** *              value is OS_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look
 484:../os_core/os_task.c **** *              this:
 485:../os_core/os_task.c **** *
 486:../os_core/os_task.c **** *                   void Task(void *p_arg)
 487:../os_core/os_task.c **** *                   {
 488:../os_core/os_task.c **** *                       .
 489:../os_core/os_task.c **** *                       .
 490:../os_core/os_task.c **** *                       while (1) {
 491:../os_core/os_task.c **** *                           OSTimeDly(1);
 492:../os_core/os_task.c **** *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_TASK_DEL_REQ) {
 493:../os_core/os_task.c **** *                               Release any owned resources;
 494:../os_core/os_task.c **** *                               De-allocate any dynamic memory;
 495:../os_core/os_task.c **** *                               OSTaskDel(OS_PRIO_SELF);
 496:../os_core/os_task.c **** *                           }
 497:../os_core/os_task.c **** *                       }
 498:../os_core/os_task.c **** *                   }
 499:../os_core/os_task.c **** *
 500:../os_core/os_task.c **** * Arguments  : prio    is the priority of the task to request the delete from
 501:../os_core/os_task.c **** *
 502:../os_core/os_task.c **** * Returns    : OS_NO_ERR          if the task exist and the request has been registered
 503:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whe
 504:../os_core/os_task.c **** *                                 the request has been executed.
 505:../os_core/os_task.c **** *              OS_TASK_DEL_ERR    if the task is assigned to a Mutex.
 506:../os_core/os_task.c **** *              OS_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
 507:../os_core/os_task.c **** *              OS_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
 508:../os_core/os_task.c **** *                                 (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 509:../os_core/os_task.c **** *              OS_TASK_DEL_REQ    if a task (possibly another task) requested that the running task
 510:../os_core/os_task.c **** *                                 deleted.
 511:../os_core/os_task.c **** ***************************************************************************************************
 512:../os_core/os_task.c **** */
 513:../os_core/os_task.c **** /*$PAGE*/
 514:../os_core/os_task.c **** #if OS_TASK_DEL_EN > 0
 515:../os_core/os_task.c **** INT8U  OSTaskDelReq (INT8U prio)
 516:../os_core/os_task.c **** {
 2627              		.loc 1 516 0
 2628              		.cfi_startproc
 2629              		@ Function supports interworking.
 2630              		@ args = 0, pretend = 0, frame = 16
 2631              		@ frame_needed = 1, uses_anonymous_args = 0
 2632 0a6c 0DC0A0E1 		mov	ip, sp
 2633              	.LCFI8:
 2634              		.cfi_def_cfa_register 12
 2635 0a70 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2636 0a74 04B04CE2 		sub	fp, ip, #4
 2637              		.cfi_offset 14, -8
 2638              		.cfi_offset 13, -12
 2639              		.cfi_offset 11, -16
 2640              	.LCFI9:
 2641              		.cfi_def_cfa 11, 4
 2642 0a78 10D04DE2 		sub	sp, sp, #16
 2643 0a7c 0030A0E1 		mov	r3, r0
 2644 0a80 15304BE5 		strb	r3, [fp, #-21]
 517:../os_core/os_task.c ****     INT8U      stat;
 518:../os_core/os_task.c ****     OS_TCB    *ptcb;
 519:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 520:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 521:../os_core/os_task.c **** 
 522:../os_core/os_task.c **** 
 523:../os_core/os_task.c **** 
 524:../os_core/os_task.c ****     cpu_sr = 0;                                                 /* Prevent compiler warning        
 525:../os_core/os_task.c **** #endif    
 526:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 527:../os_core/os_task.c ****     if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task 
 2645              		.loc 1 527 0
 2646 0a84 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2647 0a88 3F0053E3 		cmp	r3, #63
 2648 0a8c 0100001A 		bne	.L51
 528:../os_core/os_task.c ****         return (OS_TASK_DEL_IDLE);
 2649              		.loc 1 528 0
 2650 0a90 3D30A0E3 		mov	r3, #61
 2651 0a94 320000EA 		b	.L52
 2652              	.L51:
 529:../os_core/os_task.c ****     }
 530:../os_core/os_task.c ****     if (prio >= OS_LOWEST_PRIO) {						        /* Task priority valid ?               */
 2653              		.loc 1 530 0
 2654 0a98 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2655 0a9c 3E0053E3 		cmp	r3, #62
 2656 0aa0 0400009A 		bls	.L53
 531:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {                       
 2657              		.loc 1 531 0
 2658 0aa4 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2659 0aa8 FF0053E3 		cmp	r3, #255
 2660 0aac 0100000A 		beq	.L53
 532:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 2661              		.loc 1 532 0
 2662 0ab0 2A30A0E3 		mov	r3, #42
 2663 0ab4 2A0000EA 		b	.L52
 2664              	.L53:
 533:../os_core/os_task.c **** 		}
 534:../os_core/os_task.c ****     }
 535:../os_core/os_task.c **** #endif
 536:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to .
 2665              		.loc 1 536 0
 2666 0ab8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2667 0abc FF0053E3 		cmp	r3, #255
 2668 0ac0 0B00001A 		bne	.L54
 537:../os_core/os_task.c ****         OS_ENTER_CRITICAL();                                    /* ... this task to delete itself  
 2669              		.loc 1 537 0
 2670              	@ 537 "../os_core/os_task.c" 1
 2671 0ac4 00000FE1 		mrs   r0, cpsr              
 2672 0ac8 04002DE5 	stmfd sp!, {r0}             
 2673 0acc C00080E3 	orr   r0, r0, #0b11000000   
 2674 0ad0 00F021E1 	msr   cpsr_c, r0              
 2675              	@ 0 "" 2
 538:../os_core/os_task.c ****         stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller 
 2676              		.loc 1 538 0
 2677 0ad4 98309FE5 		ldr	r3, .L57
 2678 0ad8 003093E5 		ldr	r3, [r3, #0]
 2679 0adc 3330D3E5 		ldrb	r3, [r3, #51]
 2680 0ae0 0D304BE5 		strb	r3, [fp, #-13]
 539:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2681              		.loc 1 539 0
 2682              	@ 539 "../os_core/os_task.c" 1
 2683 0ae4 04009DE4 		ldmfd sp!, {r0}             
 2684 0ae8 00F021E1 	msr   cpsr_c, r0              
 2685              	@ 0 "" 2
 540:../os_core/os_task.c ****         return (stat);
 2686              		.loc 1 540 0
 2687 0aec 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 2688 0af0 1B0000EA 		b	.L52
 2689              	.L54:
 541:../os_core/os_task.c ****     }
 542:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2690              		.loc 1 542 0
 2691              	@ 542 "../os_core/os_task.c" 1
 2692 0af4 00000FE1 		mrs   r0, cpsr              
 2693 0af8 04002DE5 	stmfd sp!, {r0}             
 2694 0afc C00080E3 	orr   r0, r0, #0b11000000   
 2695 0b00 00F021E1 	msr   cpsr_c, r0              
 2696              	@ 0 "" 2
 543:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 2697              		.loc 1 543 0
 2698 0b04 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 2699 0b08 68309FE5 		ldr	r3, .L57+4
 2700 0b0c 023193E7 		ldr	r3, [r3, r2, asl #2]
 2701 0b10 14300BE5 		str	r3, [fp, #-20]
 544:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist       
 2702              		.loc 1 544 0
 2703 0b14 14301BE5 		ldr	r3, [fp, #-20]
 2704 0b18 000053E3 		cmp	r3, #0
 2705 0b1c 0300001A 		bne	.L55
 545:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2706              		.loc 1 545 0
 2707              	@ 545 "../os_core/os_task.c" 1
 2708 0b20 04009DE4 		ldmfd sp!, {r0}             
 2709 0b24 00F021E1 	msr   cpsr_c, r0              
 2710              	@ 0 "" 2
 546:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);                             /* Task must already be deleted    
 2711              		.loc 1 546 0
 2712 0b28 0B30A0E3 		mov	r3, #11
 2713 0b2c 0C0000EA 		b	.L52
 2714              	.L55:
 547:../os_core/os_task.c ****     }
 548:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                                  /* Must NOT be assigned to a Mutex 
 2715              		.loc 1 548 0
 2716 0b30 14301BE5 		ldr	r3, [fp, #-20]
 2717 0b34 010053E3 		cmp	r3, #1
 2718 0b38 0300001A 		bne	.L56
 549:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 2719              		.loc 1 549 0
 2720              	@ 549 "../os_core/os_task.c" 1
 2721 0b3c 04009DE4 		ldmfd sp!, {r0}             
 2722 0b40 00F021E1 	msr   cpsr_c, r0              
 2723              	@ 0 "" 2
 550:../os_core/os_task.c ****         return (OS_TASK_DEL_ERR);
 2724              		.loc 1 550 0
 2725 0b44 3C30A0E3 		mov	r3, #60
 2726 0b48 050000EA 		b	.L52
 2727              	.L56:
 551:../os_core/os_task.c ****     }
 552:../os_core/os_task.c ****     ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                        /* Set flag indicating task to be D
 2728              		.loc 1 552 0
 2729 0b4c 14301BE5 		ldr	r3, [fp, #-20]
 2730 0b50 3E20A0E3 		mov	r2, #62
 2731 0b54 3320C3E5 		strb	r2, [r3, #51]
 553:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 2732              		.loc 1 553 0
 2733              	@ 553 "../os_core/os_task.c" 1
 2734 0b58 04009DE4 		ldmfd sp!, {r0}             
 2735 0b5c 00F021E1 	msr   cpsr_c, r0              
 2736              	@ 0 "" 2
 554:../os_core/os_task.c ****     return (OS_NO_ERR);
 2737              		.loc 1 554 0
 2738 0b60 0030A0E3 		mov	r3, #0
 2739              	.L52:
 555:../os_core/os_task.c **** }
 2740              		.loc 1 555 0
 2741 0b64 0300A0E1 		mov	r0, r3
 2742 0b68 0CD04BE2 		sub	sp, fp, #12
 2743 0b6c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2744 0b70 1EFF2FE1 		bx	lr
 2745              	.L58:
 2746              		.align	2
 2747              	.L57:
 2748 0b74 00000000 		.word	OSTCBCur
 2749 0b78 00000000 		.word	OSTCBPrioTbl
 2750              		.cfi_endproc
 2751              	.LFE4:
 2753              		.align	2
 2754              		.global	OSTaskNameGet
 2756              	OSTaskNameGet:
 2757              	.LFB5:
 556:../os_core/os_task.c **** #endif
 557:../os_core/os_task.c **** /*$PAGE*/
 558:../os_core/os_task.c **** /*
 559:../os_core/os_task.c **** ***************************************************************************************************
 560:../os_core/os_task.c **** *                                        GET THE NAME OF A TASK
 561:../os_core/os_task.c **** *
 562:../os_core/os_task.c **** * Description: This function is called to obtain the name of a task.
 563:../os_core/os_task.c **** *
 564:../os_core/os_task.c **** * Arguments  : prio      is the priority of the task that you want to obtain the name from.
 565:../os_core/os_task.c **** *
 566:../os_core/os_task.c **** *              pname     is a pointer to an ASCII string that will receive the name of the task.  T
 567:../os_core/os_task.c **** *                        string must be able to hold at least OS_TASK_NAME_SIZE characters.
 568:../os_core/os_task.c **** *
 569:../os_core/os_task.c **** *              err       is a pointer to an error code that can contain one of the following values
 570:../os_core/os_task.c **** *
 571:../os_core/os_task.c **** *                        OS_NO_ERR                  if the requested task is resumed
 572:../os_core/os_task.c **** *                        OS_TASK_NOT_EXIST          if the task has not been created or is assigned
 573:../os_core/os_task.c **** *                        OS_PRIO_INVALID            if you specified an invalid priority:
 574:../os_core/os_task.c **** *                                                   A higher value than the idle task or not OS_PRI
 575:../os_core/os_task.c **** *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
 576:../os_core/os_task.c **** *
 577:../os_core/os_task.c **** * Returns    : The length of the string or 0 if the task does not exist.
 578:../os_core/os_task.c **** ***************************************************************************************************
 579:../os_core/os_task.c **** */
 580:../os_core/os_task.c **** 
 581:../os_core/os_task.c **** #if OS_TASK_NAME_SIZE > 1
 582:../os_core/os_task.c **** INT8U  OSTaskNameGet (INT8U prio, char *pname, INT8U *err)
 583:../os_core/os_task.c **** {
 2758              		.loc 1 583 0
 2759              		.cfi_startproc
 2760              		@ Function supports interworking.
 2761              		@ args = 0, pretend = 0, frame = 24
 2762              		@ frame_needed = 1, uses_anonymous_args = 0
 2763 0b7c 0DC0A0E1 		mov	ip, sp
 2764              	.LCFI10:
 2765              		.cfi_def_cfa_register 12
 2766 0b80 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2767 0b84 04B04CE2 		sub	fp, ip, #4
 2768              		.cfi_offset 14, -8
 2769              		.cfi_offset 13, -12
 2770              		.cfi_offset 11, -16
 2771              	.LCFI11:
 2772              		.cfi_def_cfa 11, 4
 2773 0b88 18D04DE2 		sub	sp, sp, #24
 2774 0b8c 0030A0E1 		mov	r3, r0
 2775 0b90 1C100BE5 		str	r1, [fp, #-28]
 2776 0b94 20200BE5 		str	r2, [fp, #-32]
 2777 0b98 15304BE5 		strb	r3, [fp, #-21]
 584:../os_core/os_task.c ****     OS_TCB    *ptcb;
 585:../os_core/os_task.c ****     INT8U      len;
 586:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status registe
 587:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 588:../os_core/os_task.c **** 
 589:../os_core/os_task.c **** 
 590:../os_core/os_task.c **** 
 591:../os_core/os_task.c ****     cpu_sr = 0;                                          /* Prevent compiler warning               
 592:../os_core/os_task.c **** #endif    
 593:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 594:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                  
 2778              		.loc 1 594 0
 2779 0b9c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2780 0ba0 3F0053E3 		cmp	r3, #63
 2781 0ba4 0700009A 		bls	.L60
 595:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) { 
 2782              		.loc 1 595 0
 2783 0ba8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2784 0bac FF0053E3 		cmp	r3, #255
 2785 0bb0 0400000A 		beq	.L60
 596:../os_core/os_task.c ****             *err = OS_PRIO_INVALID;                      /* No                                     
 2786              		.loc 1 596 0
 2787 0bb4 20301BE5 		ldr	r3, [fp, #-32]
 2788 0bb8 2A20A0E3 		mov	r2, #42
 2789 0bbc 0020C3E5 		strb	r2, [r3, #0]
 597:../os_core/os_task.c ****             return (0);
 2790              		.loc 1 597 0
 2791 0bc0 0030A0E3 		mov	r3, #0
 2792 0bc4 370000EA 		b	.L61
 2793              	.L60:
 598:../os_core/os_task.c ****         }
 599:../os_core/os_task.c ****     }
 600:../os_core/os_task.c ****     if (pname == (char *)0) {                             /* Is 'pname' a NULL pointer?            
 2794              		.loc 1 600 0
 2795 0bc8 1C301BE5 		ldr	r3, [fp, #-28]
 2796 0bcc 000053E3 		cmp	r3, #0
 2797 0bd0 0400001A 		bne	.L62
 601:../os_core/os_task.c ****         *err = OS_ERR_PNAME_NULL;						  /* Yes                                       */
 2798              		.loc 1 601 0
 2799 0bd4 20301BE5 		ldr	r3, [fp, #-32]
 2800 0bd8 0F20A0E3 		mov	r2, #15
 2801 0bdc 0020C3E5 		strb	r2, [r3, #0]
 602:../os_core/os_task.c ****         return (0);
 2802              		.loc 1 602 0
 2803 0be0 0030A0E3 		mov	r3, #0
 2804 0be4 2F0000EA 		b	.L61
 2805              	.L62:
 603:../os_core/os_task.c ****     }
 604:../os_core/os_task.c **** #endif
 605:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2806              		.loc 1 605 0
 2807              	@ 605 "../os_core/os_task.c" 1
 2808 0be8 00000FE1 		mrs   r0, cpsr              
 2809 0bec 04002DE5 	stmfd sp!, {r0}             
 2810 0bf0 C00080E3 	orr   r0, r0, #0b11000000   
 2811 0bf4 00F021E1 	msr   cpsr_c, r0              
 2812              	@ 0 "" 2
 606:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                           /* See if caller desires it's own name   
 2813              		.loc 1 606 0
 2814 0bf8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2815 0bfc FF0053E3 		cmp	r3, #255
 2816 0c00 0300001A 		bne	.L63
 607:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;
 2817              		.loc 1 607 0
 2818 0c04 AC309FE5 		ldr	r3, .L66
 2819 0c08 003093E5 		ldr	r3, [r3, #0]
 2820 0c0c 2E30D3E5 		ldrb	r3, [r3, #46]
 2821 0c10 15304BE5 		strb	r3, [fp, #-21]
 2822              	.L63:
 608:../os_core/os_task.c ****     }
 609:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 2823              		.loc 1 609 0
 2824 0c14 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 2825 0c18 9C309FE5 		ldr	r3, .L66+4
 2826 0c1c 023193E7 		ldr	r3, [r3, r2, asl #2]
 2827 0c20 10300BE5 		str	r3, [fp, #-16]
 610:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                            /* Does task exist?                      
 2828              		.loc 1 610 0
 2829 0c24 10301BE5 		ldr	r3, [fp, #-16]
 2830 0c28 000053E3 		cmp	r3, #0
 2831 0c2c 0600001A 		bne	.L64
 611:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                               /* No                                    
 2832              		.loc 1 611 0
 2833              	@ 611 "../os_core/os_task.c" 1
 2834 0c30 04009DE4 		ldmfd sp!, {r0}             
 2835 0c34 00F021E1 	msr   cpsr_c, r0              
 2836              	@ 0 "" 2
 612:../os_core/os_task.c ****         *err = OS_TASK_NOT_EXIST;
 2837              		.loc 1 612 0
 2838 0c38 20301BE5 		ldr	r3, [fp, #-32]
 2839 0c3c 0B20A0E3 		mov	r2, #11
 2840 0c40 0020C3E5 		strb	r2, [r3, #0]
 613:../os_core/os_task.c ****         return (0);
 2841              		.loc 1 613 0
 2842 0c44 0030A0E3 		mov	r3, #0
 2843 0c48 160000EA 		b	.L61
 2844              	.L64:
 614:../os_core/os_task.c ****     }
 615:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                            /* Task assigned to a Mutex?             
 2845              		.loc 1 615 0
 2846 0c4c 10301BE5 		ldr	r3, [fp, #-16]
 2847 0c50 010053E3 		cmp	r3, #1
 2848 0c54 0600001A 		bne	.L65
 616:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                               /* Yes                                   
 2849              		.loc 1 616 0
 2850              	@ 616 "../os_core/os_task.c" 1
 2851 0c58 04009DE4 		ldmfd sp!, {r0}             
 2852 0c5c 00F021E1 	msr   cpsr_c, r0              
 2853              	@ 0 "" 2
 617:../os_core/os_task.c ****         *err = OS_TASK_NOT_EXIST;
 2854              		.loc 1 617 0
 2855 0c60 20301BE5 		ldr	r3, [fp, #-32]
 2856 0c64 0B20A0E3 		mov	r2, #11
 2857 0c68 0020C3E5 		strb	r2, [r3, #0]
 618:../os_core/os_task.c ****         return (0);
 2858              		.loc 1 618 0
 2859 0c6c 0030A0E3 		mov	r3, #0
 2860 0c70 0C0000EA 		b	.L61
 2861              	.L65:
 619:../os_core/os_task.c ****     }
 620:../os_core/os_task.c ****     len  = OS_StrCopy(pname, ptcb->OSTCBTaskName);        /* Yes, copy name from TCB               
 2862              		.loc 1 620 0
 2863 0c74 10301BE5 		ldr	r3, [fp, #-16]
 2864 0c78 483083E2 		add	r3, r3, #72
 2865 0c7c 1C001BE5 		ldr	r0, [fp, #-28]
 2866 0c80 0310A0E1 		mov	r1, r3
 2867 0c84 FEFFFFEB 		bl	OS_StrCopy
 2868 0c88 0030A0E1 		mov	r3, r0
 2869 0c8c 11304BE5 		strb	r3, [fp, #-17]
 621:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 2870              		.loc 1 621 0
 2871              	@ 621 "../os_core/os_task.c" 1
 2872 0c90 04009DE4 		ldmfd sp!, {r0}             
 2873 0c94 00F021E1 	msr   cpsr_c, r0              
 2874              	@ 0 "" 2
 622:../os_core/os_task.c ****     *err = OS_NO_ERR;
 2875              		.loc 1 622 0
 2876 0c98 20301BE5 		ldr	r3, [fp, #-32]
 2877 0c9c 0020A0E3 		mov	r2, #0
 2878 0ca0 0020C3E5 		strb	r2, [r3, #0]
 623:../os_core/os_task.c ****     return (len);
 2879              		.loc 1 623 0
 2880 0ca4 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2881              	.L61:
 624:../os_core/os_task.c **** }
 2882              		.loc 1 624 0
 2883 0ca8 0300A0E1 		mov	r0, r3
 2884 0cac 0CD04BE2 		sub	sp, fp, #12
 2885 0cb0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2886 0cb4 1EFF2FE1 		bx	lr
 2887              	.L67:
 2888              		.align	2
 2889              	.L66:
 2890 0cb8 00000000 		.word	OSTCBCur
 2891 0cbc 00000000 		.word	OSTCBPrioTbl
 2892              		.cfi_endproc
 2893              	.LFE5:
 2895              		.align	2
 2896              		.global	OSTaskNameSet
 2898              	OSTaskNameSet:
 2899              	.LFB6:
 625:../os_core/os_task.c **** #endif
 626:../os_core/os_task.c **** 
 627:../os_core/os_task.c **** /*$PAGE*/
 628:../os_core/os_task.c **** /*
 629:../os_core/os_task.c **** ***************************************************************************************************
 630:../os_core/os_task.c **** *                                        ASSIGN A NAME TO A TASK
 631:../os_core/os_task.c **** *
 632:../os_core/os_task.c **** * Description: This function is used to set the name of a task.
 633:../os_core/os_task.c **** *
 634:../os_core/os_task.c **** * Arguments  : prio      is the priority of the task that you want the assign a name to.
 635:../os_core/os_task.c **** *
 636:../os_core/os_task.c **** *              pname     is a pointer to an ASCII string that contains the name of the task.  The A
 637:../os_core/os_task.c **** *                        string must be NUL terminated.
 638:../os_core/os_task.c **** *
 639:../os_core/os_task.c **** *              err       is a pointer to an error code that can contain one of the following values
 640:../os_core/os_task.c **** *
 641:../os_core/os_task.c **** *                        OS_NO_ERR                  if the requested task is resumed
 642:../os_core/os_task.c **** *                        OS_TASK_NOT_EXIST          if the task has not been created or is assigned
 643:../os_core/os_task.c **** *                        OS_ERR_TASK_NAME_TOO_LONG  if the name you are giving to the task exceeds 
 644:../os_core/os_task.c **** *                                                   storage capacity of a task name as specified by
 645:../os_core/os_task.c **** *                                                   OS_TASK_NAME_SIZE.
 646:../os_core/os_task.c **** *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
 647:../os_core/os_task.c **** *                        OS_PRIO_INVALID            if you specified an invalid priority:
 648:../os_core/os_task.c **** *                                                   A higher value than the idle task or not OS_PRI
 649:../os_core/os_task.c **** *
 650:../os_core/os_task.c **** * Returns    : None
 651:../os_core/os_task.c **** ***************************************************************************************************
 652:../os_core/os_task.c **** */
 653:../os_core/os_task.c **** #if OS_TASK_NAME_SIZE > 1
 654:../os_core/os_task.c **** void  OSTaskNameSet (INT8U prio, char *pname, INT8U *err)
 655:../os_core/os_task.c **** {
 2900              		.loc 1 655 0
 2901              		.cfi_startproc
 2902              		@ Function supports interworking.
 2903              		@ args = 0, pretend = 0, frame = 24
 2904              		@ frame_needed = 1, uses_anonymous_args = 0
 2905 0cc0 0DC0A0E1 		mov	ip, sp
 2906              	.LCFI12:
 2907              		.cfi_def_cfa_register 12
 2908 0cc4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2909 0cc8 04B04CE2 		sub	fp, ip, #4
 2910              		.cfi_offset 14, -8
 2911              		.cfi_offset 13, -12
 2912              		.cfi_offset 11, -16
 2913              	.LCFI13:
 2914              		.cfi_def_cfa 11, 4
 2915 0ccc 18D04DE2 		sub	sp, sp, #24
 2916 0cd0 0030A0E1 		mov	r3, r0
 2917 0cd4 1C100BE5 		str	r1, [fp, #-28]
 2918 0cd8 20200BE5 		str	r2, [fp, #-32]
 2919 0cdc 15304BE5 		strb	r3, [fp, #-21]
 656:../os_core/os_task.c ****     INT8U      len;
 657:../os_core/os_task.c ****     OS_TCB    *ptcb;
 658:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register   
 659:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 660:../os_core/os_task.c **** 
 661:../os_core/os_task.c **** 
 662:../os_core/os_task.c **** 
 663:../os_core/os_task.c ****     cpu_sr = 0;                                      /* Prevent compiler warning                   
 664:../os_core/os_task.c **** #endif    
 665:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 666:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                      
 2920              		.loc 1 666 0
 2921 0ce0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2922 0ce4 3F0053E3 		cmp	r3, #63
 2923 0ce8 0600009A 		bls	.L69
 667:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {              
 2924              		.loc 1 667 0
 2925 0cec 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2926 0cf0 FF0053E3 		cmp	r3, #255
 2927 0cf4 0300000A 		beq	.L69
 668:../os_core/os_task.c ****             *err = OS_PRIO_INVALID;                  /* No                                         
 2928              		.loc 1 668 0
 2929 0cf8 20301BE5 		ldr	r3, [fp, #-32]
 2930 0cfc 2A20A0E3 		mov	r2, #42
 2931 0d00 0020C3E5 		strb	r2, [r3, #0]
 669:../os_core/os_task.c ****             return;
 2932              		.loc 1 669 0
 2933 0d04 3E0000EA 		b	.L68
 2934              	.L69:
 670:../os_core/os_task.c ****         }
 671:../os_core/os_task.c ****     }
 672:../os_core/os_task.c ****     if (pname == (char *)0) {                        /* Is 'pname' a NULL pointer?                 
 2935              		.loc 1 672 0
 2936 0d08 1C301BE5 		ldr	r3, [fp, #-28]
 2937 0d0c 000053E3 		cmp	r3, #0
 2938 0d10 0300001A 		bne	.L71
 673:../os_core/os_task.c ****         *err = OS_ERR_PNAME_NULL;					 /* Yes                                            */
 2939              		.loc 1 673 0
 2940 0d14 20301BE5 		ldr	r3, [fp, #-32]
 2941 0d18 0F20A0E3 		mov	r2, #15
 2942 0d1c 0020C3E5 		strb	r2, [r3, #0]
 674:../os_core/os_task.c ****         return;
 2943              		.loc 1 674 0
 2944 0d20 370000EA 		b	.L68
 2945              	.L71:
 675:../os_core/os_task.c ****     }
 676:../os_core/os_task.c **** #endif
 677:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 2946              		.loc 1 677 0
 2947              	@ 677 "../os_core/os_task.c" 1
 2948 0d24 00000FE1 		mrs   r0, cpsr              
 2949 0d28 04002DE5 	stmfd sp!, {r0}             
 2950 0d2c C00080E3 	orr   r0, r0, #0b11000000   
 2951 0d30 00F021E1 	msr   cpsr_c, r0              
 2952              	@ 0 "" 2
 678:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name 
 2953              		.loc 1 678 0
 2954 0d34 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 2955 0d38 FF0053E3 		cmp	r3, #255
 2956 0d3c 0300001A 		bne	.L72
 679:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;
 2957              		.loc 1 679 0
 2958 0d40 C8309FE5 		ldr	r3, .L76
 2959 0d44 003093E5 		ldr	r3, [r3, #0]
 2960 0d48 2E30D3E5 		ldrb	r3, [r3, #46]
 2961 0d4c 15304BE5 		strb	r3, [fp, #-21]
 2962              	.L72:
 680:../os_core/os_task.c ****     }
 681:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 2963              		.loc 1 681 0
 2964 0d50 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 2965 0d54 B8309FE5 		ldr	r3, .L76+4
 2966 0d58 023193E7 		ldr	r3, [r3, r2, asl #2]
 2967 0d5c 10300BE5 		str	r3, [fp, #-16]
 682:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                           
 2968              		.loc 1 682 0
 2969 0d60 10301BE5 		ldr	r3, [fp, #-16]
 2970 0d64 000053E3 		cmp	r3, #0
 2971 0d68 0500001A 		bne	.L73
 683:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                          /* No                                         
 2972              		.loc 1 683 0
 2973              	@ 683 "../os_core/os_task.c" 1
 2974 0d6c 04009DE4 		ldmfd sp!, {r0}             
 2975 0d70 00F021E1 	msr   cpsr_c, r0              
 2976              	@ 0 "" 2
 684:../os_core/os_task.c ****         *err = OS_TASK_NOT_EXIST;
 2977              		.loc 1 684 0
 2978 0d74 20301BE5 		ldr	r3, [fp, #-32]
 2979 0d78 0B20A0E3 		mov	r2, #11
 2980 0d7c 0020C3E5 		strb	r2, [r3, #0]
 685:../os_core/os_task.c ****         return;
 2981              		.loc 1 685 0
 2982 0d80 1F0000EA 		b	.L68
 2983              	.L73:
 686:../os_core/os_task.c ****     }
 687:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                       /* Task assigned to a Mutex?                  
 2984              		.loc 1 687 0
 2985 0d84 10301BE5 		ldr	r3, [fp, #-16]
 2986 0d88 010053E3 		cmp	r3, #1
 2987 0d8c 0500001A 		bne	.L74
 688:../os_core/os_task.c ****         OS_EXIT_CRITICAL();                          /* Yes                                        
 2988              		.loc 1 688 0
 2989              	@ 688 "../os_core/os_task.c" 1
 2990 0d90 04009DE4 		ldmfd sp!, {r0}             
 2991 0d94 00F021E1 	msr   cpsr_c, r0              
 2992              	@ 0 "" 2
 689:../os_core/os_task.c ****         *err = OS_TASK_NOT_EXIST;
 2993              		.loc 1 689 0
 2994 0d98 20301BE5 		ldr	r3, [fp, #-32]
 2995 0d9c 0B20A0E3 		mov	r2, #11
 2996 0da0 0020C3E5 		strb	r2, [r3, #0]
 690:../os_core/os_task.c ****         return;
 2997              		.loc 1 690 0
 2998 0da4 160000EA 		b	.L68
 2999              	.L74:
 691:../os_core/os_task.c ****     }
 692:../os_core/os_task.c ****     len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?     
 3000              		.loc 1 692 0
 3001 0da8 1C001BE5 		ldr	r0, [fp, #-28]
 3002 0dac FEFFFFEB 		bl	OS_StrLen
 3003 0db0 0030A0E1 		mov	r3, r0
 3004 0db4 11304BE5 		strb	r3, [fp, #-17]
 693:../os_core/os_task.c ****     if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                    
 3005              		.loc 1 693 0
 3006 0db8 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3007 0dbc 1F0053E3 		cmp	r3, #31
 3008 0dc0 0500009A 		bls	.L75
 694:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3009              		.loc 1 694 0
 3010              	@ 694 "../os_core/os_task.c" 1
 3011 0dc4 04009DE4 		ldmfd sp!, {r0}             
 3012 0dc8 00F021E1 	msr   cpsr_c, r0              
 3013              	@ 0 "" 2
 695:../os_core/os_task.c ****         *err = OS_ERR_TASK_NAME_TOO_LONG;
 3014              		.loc 1 695 0
 3015 0dcc 20301BE5 		ldr	r3, [fp, #-32]
 3016 0dd0 0E20A0E3 		mov	r2, #14
 3017 0dd4 0020C3E5 		strb	r2, [r3, #0]
 696:../os_core/os_task.c ****         return;
 3018              		.loc 1 696 0
 3019 0dd8 090000EA 		b	.L68
 3020              	.L75:
 697:../os_core/os_task.c ****     } 
 698:../os_core/os_task.c ****     (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                      
 3021              		.loc 1 698 0
 3022 0ddc 10301BE5 		ldr	r3, [fp, #-16]
 3023 0de0 483083E2 		add	r3, r3, #72
 3024 0de4 0300A0E1 		mov	r0, r3
 3025 0de8 1C101BE5 		ldr	r1, [fp, #-28]
 3026 0dec FEFFFFEB 		bl	OS_StrCopy
 699:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 3027              		.loc 1 699 0
 3028              	@ 699 "../os_core/os_task.c" 1
 3029 0df0 04009DE4 		ldmfd sp!, {r0}             
 3030 0df4 00F021E1 	msr   cpsr_c, r0              
 3031              	@ 0 "" 2
 700:../os_core/os_task.c ****     *err = OS_NO_ERR;
 3032              		.loc 1 700 0
 3033 0df8 20301BE5 		ldr	r3, [fp, #-32]
 3034 0dfc 0020A0E3 		mov	r2, #0
 3035 0e00 0020C3E5 		strb	r2, [r3, #0]
 3036              	.L68:
 701:../os_core/os_task.c **** }
 3037              		.loc 1 701 0
 3038 0e04 0CD04BE2 		sub	sp, fp, #12
 3039 0e08 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3040 0e0c 1EFF2FE1 		bx	lr
 3041              	.L77:
 3042              		.align	2
 3043              	.L76:
 3044 0e10 00000000 		.word	OSTCBCur
 3045 0e14 00000000 		.word	OSTCBPrioTbl
 3046              		.cfi_endproc
 3047              	.LFE6:
 3049              		.align	2
 3050              		.global	OSTaskResume
 3052              	OSTaskResume:
 3053              	.LFB7:
 702:../os_core/os_task.c **** #endif
 703:../os_core/os_task.c **** 
 704:../os_core/os_task.c **** /*$PAGE*/
 705:../os_core/os_task.c **** /*
 706:../os_core/os_task.c **** ***************************************************************************************************
 707:../os_core/os_task.c **** *                                        RESUME A SUSPENDED TASK
 708:../os_core/os_task.c **** *
 709:../os_core/os_task.c **** * Description: This function is called to resume a previously suspended task.  This is the only cal
 710:../os_core/os_task.c **** *              will remove an explicit task suspension.
 711:../os_core/os_task.c **** *
 712:../os_core/os_task.c **** * Arguments  : prio     is the priority of the task to resume.
 713:../os_core/os_task.c **** *
 714:../os_core/os_task.c **** * Returns    : OS_NO_ERR                if the requested task is resumed
 715:../os_core/os_task.c **** *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allo
 716:../os_core/os_task.c **** *                                       (i.e. >= OS_LOWEST_PRIO)
 717:../os_core/os_task.c **** *              OS_TASK_RESUME_PRIO      if the task to resume does not exist
 718:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST        if the task is assigned to a Mutex PIP
 719:../os_core/os_task.c **** *              OS_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
 720:../os_core/os_task.c **** ***************************************************************************************************
 721:../os_core/os_task.c **** */
 722:../os_core/os_task.c **** 
 723:../os_core/os_task.c **** #if OS_TASK_SUSPEND_EN > 0
 724:../os_core/os_task.c **** INT8U  OSTaskResume (INT8U prio)
 725:../os_core/os_task.c **** {
 3054              		.loc 1 725 0
 3055              		.cfi_startproc
 3056              		@ Function supports interworking.
 3057              		@ args = 0, pretend = 0, frame = 16
 3058              		@ frame_needed = 1, uses_anonymous_args = 0
 3059 0e18 0DC0A0E1 		mov	ip, sp
 3060              	.LCFI14:
 3061              		.cfi_def_cfa_register 12
 3062 0e1c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3063 0e20 04B04CE2 		sub	fp, ip, #4
 3064              		.cfi_offset 14, -8
 3065              		.cfi_offset 13, -12
 3066              		.cfi_offset 11, -16
 3067              	.LCFI15:
 3068              		.cfi_def_cfa 11, 4
 3069 0e24 10D04DE2 		sub	sp, sp, #16
 3070 0e28 0030A0E1 		mov	r3, r0
 3071 0e2c 15304BE5 		strb	r3, [fp, #-21]
 726:../os_core/os_task.c ****     OS_TCB    *ptcb;
 727:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register   
 728:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 729:../os_core/os_task.c **** 
 730:../os_core/os_task.c **** 
 731:../os_core/os_task.c **** 
 732:../os_core/os_task.c ****     cpu_sr = 0;                                               /* Prevent compiler warning          
 733:../os_core/os_task.c **** #endif    
 734:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 735:../os_core/os_task.c ****     if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid  
 3072              		.loc 1 735 0
 3073 0e30 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3074 0e34 3E0053E3 		cmp	r3, #62
 3075 0e38 0100009A 		bls	.L79
 736:../os_core/os_task.c ****         return (OS_PRIO_INVALID);
 3076              		.loc 1 736 0
 3077 0e3c 2A30A0E3 		mov	r3, #42
 3078 0e40 4A0000EA 		b	.L80
 3079              	.L79:
 737:../os_core/os_task.c ****     }
 738:../os_core/os_task.c **** #endif
 739:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 3080              		.loc 1 739 0
 3081              	@ 739 "../os_core/os_task.c" 1
 3082 0e44 00000FE1 		mrs   r0, cpsr              
 3083 0e48 04002DE5 	stmfd sp!, {r0}             
 3084 0e4c C00080E3 	orr   r0, r0, #0b11000000   
 3085 0e50 00F021E1 	msr   cpsr_c, r0              
 3086              	@ 0 "" 2
 740:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 3087              		.loc 1 740 0
 3088 0e54 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3089 0e58 20319FE5 		ldr	r3, .L87
 3090 0e5c 023193E7 		ldr	r3, [r3, r2, asl #2]
 3091 0e60 10300BE5 		str	r3, [fp, #-16]
 741:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist        
 3092              		.loc 1 741 0
 3093 0e64 10301BE5 		ldr	r3, [fp, #-16]
 3094 0e68 000053E3 		cmp	r3, #0
 3095 0e6c 0300001A 		bne	.L81
 742:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3096              		.loc 1 742 0
 3097              	@ 742 "../os_core/os_task.c" 1
 3098 0e70 04009DE4 		ldmfd sp!, {r0}             
 3099 0e74 00F021E1 	msr   cpsr_c, r0              
 3100              	@ 0 "" 2
 743:../os_core/os_task.c ****         return (OS_TASK_RESUME_PRIO);
 3101              		.loc 1 743 0
 3102 0e78 6430A0E3 		mov	r3, #100
 3103 0e7c 3B0000EA 		b	.L80
 3104              	.L81:
 744:../os_core/os_task.c ****     }
 745:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                                /* See if assigned to Mutex          
 3105              		.loc 1 745 0
 3106 0e80 10301BE5 		ldr	r3, [fp, #-16]
 3107 0e84 010053E3 		cmp	r3, #1
 3108 0e88 0300001A 		bne	.L82
 746:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3109              		.loc 1 746 0
 3110              	@ 746 "../os_core/os_task.c" 1
 3111 0e8c 04009DE4 		ldmfd sp!, {r0}             
 3112 0e90 00F021E1 	msr   cpsr_c, r0              
 3113              	@ 0 "" 2
 747:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 3114              		.loc 1 747 0
 3115 0e94 0B30A0E3 		mov	r3, #11
 3116 0e98 340000EA 		b	.L80
 3117              	.L82:
 748:../os_core/os_task.c ****     }
 749:../os_core/os_task.c ****     if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended            
 3118              		.loc 1 749 0
 3119 0e9c 10301BE5 		ldr	r3, [fp, #-16]
 3120 0ea0 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 3121 0ea4 083003E2 		and	r3, r3, #8
 3122 0ea8 000053E3 		cmp	r3, #0
 3123 0eac 2C00000A 		beq	.L83
 750:../os_core/os_task.c ****         ptcb->OSTCBStat &= ~OS_STAT_SUSPEND;				  /* Remove suspension                     */
 3124              		.loc 1 750 0
 3125 0eb0 10301BE5 		ldr	r3, [fp, #-16]
 3126 0eb4 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 3127 0eb8 0830C3E3 		bic	r3, r3, #8
 3128 0ebc FF2003E2 		and	r2, r3, #255
 3129 0ec0 10301BE5 		ldr	r3, [fp, #-16]
 3130 0ec4 2C20C3E5 		strb	r2, [r3, #44]
 751:../os_core/os_task.c ****         if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready          
 3131              		.loc 1 751 0
 3132 0ec8 10301BE5 		ldr	r3, [fp, #-16]
 3133 0ecc 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 3134 0ed0 000053E3 		cmp	r3, #0
 3135 0ed4 1E00001A 		bne	.L84
 752:../os_core/os_task.c ****             if (ptcb->OSTCBDly == 0) {
 3136              		.loc 1 752 0
 3137 0ed8 10301BE5 		ldr	r3, [fp, #-16]
 3138 0edc BA32D3E1 		ldrh	r3, [r3, #42]
 3139 0ee0 000053E3 		cmp	r3, #0
 3140 0ee4 1700001A 		bne	.L85
 753:../os_core/os_task.c ****                 OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run       
 3141              		.loc 1 753 0
 3142 0ee8 10301BE5 		ldr	r3, [fp, #-16]
 3143 0eec 3220D3E5 		ldrb	r2, [r3, #50]	@ zero_extendqisi2
 3144 0ef0 8C309FE5 		ldr	r3, .L87+4
 3145 0ef4 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3146 0ef8 033082E1 		orr	r3, r2, r3
 3147 0efc FF2003E2 		and	r2, r3, #255
 3148 0f00 7C309FE5 		ldr	r3, .L87+4
 3149 0f04 0020C3E5 		strb	r2, [r3, #0]
 754:../os_core/os_task.c ****                 OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 3150              		.loc 1 754 0
 3151 0f08 10301BE5 		ldr	r3, [fp, #-16]
 3152 0f0c 3030D3E5 		ldrb	r3, [r3, #48]	@ zero_extendqisi2
 3153 0f10 10201BE5 		ldr	r2, [fp, #-16]
 3154 0f14 3020D2E5 		ldrb	r2, [r2, #48]	@ zero_extendqisi2
 3155 0f18 68109FE5 		ldr	r1, .L87+8
 3156 0f1c 0210D1E7 		ldrb	r1, [r1, r2]	@ zero_extendqisi2
 3157 0f20 10201BE5 		ldr	r2, [fp, #-16]
 3158 0f24 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 3159 0f28 022081E1 		orr	r2, r1, r2
 3160 0f2c FF1002E2 		and	r1, r2, #255
 3161 0f30 50209FE5 		ldr	r2, .L87+8
 3162 0f34 0310C2E7 		strb	r1, [r2, r3]
 755:../os_core/os_task.c ****                 OS_EXIT_CRITICAL();
 3163              		.loc 1 755 0
 3164              	@ 755 "../os_core/os_task.c" 1
 3165 0f38 04009DE4 		ldmfd sp!, {r0}             
 3166 0f3c 00F021E1 	msr   cpsr_c, r0              
 3167              	@ 0 "" 2
 756:../os_core/os_task.c ****                 OS_Sched();
 3168              		.loc 1 756 0
 3169 0f40 FEFFFFEB 		bl	OS_Sched
 3170 0f44 040000EA 		b	.L86
 3171              	.L85:
 757:../os_core/os_task.c ****             } else {
 758:../os_core/os_task.c ****                 OS_EXIT_CRITICAL();
 3172              		.loc 1 758 0
 3173              	@ 758 "../os_core/os_task.c" 1
 3174 0f48 04009DE4 		ldmfd sp!, {r0}             
 3175 0f4c 00F021E1 	msr   cpsr_c, r0              
 3176              	@ 0 "" 2
 3177 0f50 010000EA 		b	.L86
 3178              	.L84:
 759:../os_core/os_task.c ****             }
 760:../os_core/os_task.c ****         } else {                                              /* Must be pending on event          
 761:../os_core/os_task.c **** 		    OS_EXIT_CRITICAL();
 3179              		.loc 1 761 0
 3180              	@ 761 "../os_core/os_task.c" 1
 3181 0f54 04009DE4 		ldmfd sp!, {r0}             
 3182 0f58 00F021E1 	msr   cpsr_c, r0              
 3183              	@ 0 "" 2
 3184              	.L86:
 762:../os_core/os_task.c ****         }
 763:../os_core/os_task.c ****         return (OS_NO_ERR);
 3185              		.loc 1 763 0
 3186 0f5c 0030A0E3 		mov	r3, #0
 3187 0f60 020000EA 		b	.L80
 3188              	.L83:
 764:../os_core/os_task.c ****     }
 765:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 3189              		.loc 1 765 0
 3190              	@ 765 "../os_core/os_task.c" 1
 3191 0f64 04009DE4 		ldmfd sp!, {r0}             
 3192 0f68 00F021E1 	msr   cpsr_c, r0              
 3193              	@ 0 "" 2
 766:../os_core/os_task.c ****     return (OS_TASK_NOT_SUSPENDED);
 3194              		.loc 1 766 0
 3195 0f6c 6530A0E3 		mov	r3, #101
 3196              	.L80:
 767:../os_core/os_task.c **** }
 3197              		.loc 1 767 0
 3198 0f70 0300A0E1 		mov	r0, r3
 3199 0f74 0CD04BE2 		sub	sp, fp, #12
 3200 0f78 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3201 0f7c 1EFF2FE1 		bx	lr
 3202              	.L88:
 3203              		.align	2
 3204              	.L87:
 3205 0f80 00000000 		.word	OSTCBPrioTbl
 3206 0f84 00000000 		.word	OSRdyGrp
 3207 0f88 00000000 		.word	OSRdyTbl
 3208              		.cfi_endproc
 3209              	.LFE7:
 3211              		.align	2
 3212              		.global	OSTaskStkChk
 3214              	OSTaskStkChk:
 3215              	.LFB8:
 768:../os_core/os_task.c **** #endif
 769:../os_core/os_task.c **** /*$PAGE*/
 770:../os_core/os_task.c **** /*
 771:../os_core/os_task.c **** ***************************************************************************************************
 772:../os_core/os_task.c **** *                                             STACK CHECKING
 773:../os_core/os_task.c **** *
 774:../os_core/os_task.c **** * Description: This function is called to check the amount of free memory left on the specified tas
 775:../os_core/os_task.c **** *              stack.
 776:../os_core/os_task.c **** *
 777:../os_core/os_task.c **** * Arguments  : prio          is the task priority
 778:../os_core/os_task.c **** *
 779:../os_core/os_task.c **** *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
 780:../os_core/os_task.c **** *
 781:../os_core/os_task.c **** * Returns    : OS_NO_ERR           upon success
 782:../os_core/os_task.c **** *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
 783:../os_core/os_task.c **** *                                  (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 784:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST   if the desired task has not been created or is assigned to a Mut
 785:../os_core/os_task.c **** *              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was c
 786:../os_core/os_task.c **** ***************************************************************************************************
 787:../os_core/os_task.c **** */
 788:../os_core/os_task.c **** #if OS_TASK_CREATE_EXT_EN > 0
 789:../os_core/os_task.c **** INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
 790:../os_core/os_task.c **** {
 3216              		.loc 1 790 0
 3217              		.cfi_startproc
 3218              		@ Function supports interworking.
 3219              		@ args = 0, pretend = 0, frame = 24
 3220              		@ frame_needed = 1, uses_anonymous_args = 0
 3221 0f8c 0DC0A0E1 		mov	ip, sp
 3222              	.LCFI16:
 3223              		.cfi_def_cfa_register 12
 3224 0f90 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3225 0f94 04B04CE2 		sub	fp, ip, #4
 3226              		.cfi_offset 14, -8
 3227              		.cfi_offset 13, -12
 3228              		.cfi_offset 11, -16
 3229              	.LCFI17:
 3230              		.cfi_def_cfa 11, 4
 3231 0f98 18D04DE2 		sub	sp, sp, #24
 3232 0f9c 0030A0E1 		mov	r3, r0
 3233 0fa0 24100BE5 		str	r1, [fp, #-36]
 3234 0fa4 1D304BE5 		strb	r3, [fp, #-29]
 791:../os_core/os_task.c ****     OS_TCB    *ptcb;
 792:../os_core/os_task.c ****     OS_STK    *pchk;
 793:../os_core/os_task.c ****     INT32U     free;
 794:../os_core/os_task.c ****     INT32U     size;
 795:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register 
 796:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 797:../os_core/os_task.c **** 
 798:../os_core/os_task.c **** 
 799:../os_core/os_task.c **** 
 800:../os_core/os_task.c ****     cpu_sr = 0;                                        /* Prevent compiler warning                 
 801:../os_core/os_task.c **** #endif    
 802:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 803:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {					   /* Make sure task priority is valid             */
 3235              		.loc 1 803 0
 3236 0fa8 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3237 0fac 3F0053E3 		cmp	r3, #63
 3238 0fb0 0400009A 		bls	.L90
 804:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {        
 3239              		.loc 1 804 0
 3240 0fb4 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3241 0fb8 FF0053E3 		cmp	r3, #255
 3242 0fbc 0100000A 		beq	.L90
 805:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 3243              		.loc 1 805 0
 3244 0fc0 2A30A0E3 		mov	r3, #42
 3245 0fc4 4F0000EA 		b	.L91
 3246              	.L90:
 806:../os_core/os_task.c ****         }
 807:../os_core/os_task.c ****     }
 808:../os_core/os_task.c **** #endif
 809:../os_core/os_task.c ****     p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size            
 3247              		.loc 1 809 0
 3248 0fc8 24301BE5 		ldr	r3, [fp, #-36]
 3249 0fcc 0020A0E3 		mov	r2, #0
 3250 0fd0 002083E5 		str	r2, [r3, #0]
 810:../os_core/os_task.c ****     p_stk_data->OSUsed = 0;
 3251              		.loc 1 810 0
 3252 0fd4 24301BE5 		ldr	r3, [fp, #-36]
 3253 0fd8 0020A0E3 		mov	r2, #0
 3254 0fdc 042083E5 		str	r2, [r3, #4]
 811:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 3255              		.loc 1 811 0
 3256              	@ 811 "../os_core/os_task.c" 1
 3257 0fe0 00000FE1 		mrs   r0, cpsr              
 3258 0fe4 04002DE5 	stmfd sp!, {r0}             
 3259 0fe8 C00080E3 	orr   r0, r0, #0b11000000   
 3260 0fec 00F021E1 	msr   cpsr_c, r0              
 3261              	@ 0 "" 2
 812:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                    
 3262              		.loc 1 812 0
 3263 0ff0 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3264 0ff4 FF0053E3 		cmp	r3, #255
 3265 0ff8 0300001A 		bne	.L92
 813:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;
 3266              		.loc 1 813 0
 3267 0ffc 14319FE5 		ldr	r3, .L98
 3268 1000 003093E5 		ldr	r3, [r3, #0]
 3269 1004 2E30D3E5 		ldrb	r3, [r3, #46]
 3270 1008 1D304BE5 		strb	r3, [fp, #-29]
 3271              	.L92:
 814:../os_core/os_task.c ****     }
 815:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 3272              		.loc 1 815 0
 3273 100c 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 3274 1010 04319FE5 		ldr	r3, .L98+4
 3275 1014 023193E7 		ldr	r3, [r3, r2, asl #2]
 3276 1018 18300BE5 		str	r3, [fp, #-24]
 816:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                     
 3277              		.loc 1 816 0
 3278 101c 18301BE5 		ldr	r3, [fp, #-24]
 3279 1020 000053E3 		cmp	r3, #0
 3280 1024 0300001A 		bne	.L93
 817:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3281              		.loc 1 817 0
 3282              	@ 817 "../os_core/os_task.c" 1
 3283 1028 04009DE4 		ldmfd sp!, {r0}             
 3284 102c 00F021E1 	msr   cpsr_c, r0              
 3285              	@ 0 "" 2
 818:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 3286              		.loc 1 818 0
 3287 1030 0B30A0E3 		mov	r3, #11
 3288 1034 330000EA 		b	.L91
 3289              	.L93:
 819:../os_core/os_task.c ****     }
 820:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {
 3290              		.loc 1 820 0
 3291 1038 18301BE5 		ldr	r3, [fp, #-24]
 3292 103c 010053E3 		cmp	r3, #1
 3293 1040 0300001A 		bne	.L94
 821:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3294              		.loc 1 821 0
 3295              	@ 821 "../os_core/os_task.c" 1
 3296 1044 04009DE4 		ldmfd sp!, {r0}             
 3297 1048 00F021E1 	msr   cpsr_c, r0              
 3298              	@ 0 "" 2
 822:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 3299              		.loc 1 822 0
 3300 104c 0B30A0E3 		mov	r3, #11
 3301 1050 2C0000EA 		b	.L91
 3302              	.L94:
 823:../os_core/os_task.c ****     }  
 824:../os_core/os_task.c ****     if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set   
 3303              		.loc 1 824 0
 3304 1054 18301BE5 		ldr	r3, [fp, #-24]
 3305 1058 B031D3E1 		ldrh	r3, [r3, #16]
 3306 105c 013003E2 		and	r3, r3, #1
 3307 1060 000053E3 		cmp	r3, #0
 3308 1064 0300001A 		bne	.L95
 825:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3309              		.loc 1 825 0
 3310              	@ 825 "../os_core/os_task.c" 1
 3311 1068 04009DE4 		ldmfd sp!, {r0}             
 3312 106c 00F021E1 	msr   cpsr_c, r0              
 3313              	@ 0 "" 2
 826:../os_core/os_task.c ****         return (OS_TASK_OPT_ERR);
 3314              		.loc 1 826 0
 3315 1070 8230A0E3 		mov	r3, #130
 3316 1074 230000EA 		b	.L91
 3317              	.L95:
 827:../os_core/os_task.c ****     }
 828:../os_core/os_task.c ****     free = 0;
 3318              		.loc 1 828 0
 3319 1078 0030A0E3 		mov	r3, #0
 3320 107c 14300BE5 		str	r3, [fp, #-20]
 829:../os_core/os_task.c ****     size = ptcb->OSTCBStkSize;
 3321              		.loc 1 829 0
 3322 1080 18301BE5 		ldr	r3, [fp, #-24]
 3323 1084 0C3093E5 		ldr	r3, [r3, #12]
 3324 1088 1C300BE5 		str	r3, [fp, #-28]
 830:../os_core/os_task.c ****     pchk = ptcb->OSTCBStkBottom;
 3325              		.loc 1 830 0
 3326 108c 18301BE5 		ldr	r3, [fp, #-24]
 3327 1090 083093E5 		ldr	r3, [r3, #8]
 3328 1094 10300BE5 		str	r3, [fp, #-16]
 831:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 3329              		.loc 1 831 0
 3330              	@ 831 "../os_core/os_task.c" 1
 3331 1098 04009DE4 		ldmfd sp!, {r0}             
 3332 109c 00F021E1 	msr   cpsr_c, r0              
 3333              	@ 0 "" 2
 832:../os_core/os_task.c **** #if OS_STK_GROWTH == 1
 833:../os_core/os_task.c ****     while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the 
 3334              		.loc 1 833 0
 3335 10a0 020000EA 		b	.L96
 3336              	.L97:
 834:../os_core/os_task.c ****         free++;
 3337              		.loc 1 834 0
 3338 10a4 14301BE5 		ldr	r3, [fp, #-20]
 3339 10a8 013083E2 		add	r3, r3, #1
 3340 10ac 14300BE5 		str	r3, [fp, #-20]
 3341              	.L96:
 833:../os_core/os_task.c ****     while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the 
 3342              		.loc 1 833 0 discriminator 1
 3343 10b0 10301BE5 		ldr	r3, [fp, #-16]
 3344 10b4 003093E5 		ldr	r3, [r3, #0]
 3345 10b8 000053E3 		cmp	r3, #0
 3346 10bc 0030A013 		movne	r3, #0
 3347 10c0 0130A003 		moveq	r3, #1
 3348 10c4 FF3003E2 		and	r3, r3, #255
 3349 10c8 10201BE5 		ldr	r2, [fp, #-16]
 3350 10cc 042082E2 		add	r2, r2, #4
 3351 10d0 10200BE5 		str	r2, [fp, #-16]
 3352 10d4 000053E3 		cmp	r3, #0
 3353 10d8 F1FFFF1A 		bne	.L97
 835:../os_core/os_task.c ****     }
 836:../os_core/os_task.c **** #else
 837:../os_core/os_task.c ****     while (*pchk-- == (OS_STK)0) {
 838:../os_core/os_task.c ****         free++;
 839:../os_core/os_task.c ****     }
 840:../os_core/os_task.c **** #endif
 841:../os_core/os_task.c ****     p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the st
 3354              		.loc 1 841 0
 3355 10dc 14301BE5 		ldr	r3, [fp, #-20]
 3356 10e0 0321A0E1 		mov	r2, r3, asl #2
 3357 10e4 24301BE5 		ldr	r3, [fp, #-36]
 3358 10e8 002083E5 		str	r2, [r3, #0]
 842:../os_core/os_task.c ****     p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the st
 3359              		.loc 1 842 0
 3360 10ec 1C201BE5 		ldr	r2, [fp, #-28]
 3361 10f0 14301BE5 		ldr	r3, [fp, #-20]
 3362 10f4 023063E0 		rsb	r3, r3, r2
 3363 10f8 0321A0E1 		mov	r2, r3, asl #2
 3364 10fc 24301BE5 		ldr	r3, [fp, #-36]
 3365 1100 042083E5 		str	r2, [r3, #4]
 843:../os_core/os_task.c ****     return (OS_NO_ERR);
 3366              		.loc 1 843 0
 3367 1104 0030A0E3 		mov	r3, #0
 3368              	.L91:
 844:../os_core/os_task.c **** }
 3369              		.loc 1 844 0
 3370 1108 0300A0E1 		mov	r0, r3
 3371 110c 0CD04BE2 		sub	sp, fp, #12
 3372 1110 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3373 1114 1EFF2FE1 		bx	lr
 3374              	.L99:
 3375              		.align	2
 3376              	.L98:
 3377 1118 00000000 		.word	OSTCBCur
 3378 111c 00000000 		.word	OSTCBPrioTbl
 3379              		.cfi_endproc
 3380              	.LFE8:
 3382              		.align	2
 3383              		.global	OSTaskSuspend
 3385              	OSTaskSuspend:
 3386              	.LFB9:
 845:../os_core/os_task.c **** #endif
 846:../os_core/os_task.c **** /*$PAGE*/
 847:../os_core/os_task.c **** /*
 848:../os_core/os_task.c **** ***************************************************************************************************
 849:../os_core/os_task.c **** *                                            SUSPEND A TASK
 850:../os_core/os_task.c **** *
 851:../os_core/os_task.c **** * Description: This function is called to suspend a task.  The task can be the calling task if the
 852:../os_core/os_task.c **** *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SE
 853:../os_core/os_task.c **** *
 854:../os_core/os_task.c **** * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
 855:../os_core/os_task.c **** *                       calling task will suspend itself and rescheduling will occur.
 856:../os_core/os_task.c **** *
 857:../os_core/os_task.c **** * Returns    : OS_NO_ERR                if the requested task is suspended
 858:../os_core/os_task.c **** *              OS_TASK_SUSPEND_IDLE     if you attempted to suspend the idle task which is not allo
 859:../os_core/os_task.c **** *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allo
 860:../os_core/os_task.c **** *                                       (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO
 861:../os_core/os_task.c **** *              OS_TASK_SUSPEND_PRIO     if the task to suspend does not exist
 862:../os_core/os_task.c **** *              OS_TASK_NOT_EXITS        if the task is assigned to a Mutex PIP
 863:../os_core/os_task.c **** *
 864:../os_core/os_task.c **** * Note       : You should use this function with great care.  If you suspend a task that is waiting
 865:../os_core/os_task.c **** *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
 866:../os_core/os_task.c **** *              running when the event arrives.
 867:../os_core/os_task.c **** ***************************************************************************************************
 868:../os_core/os_task.c **** */
 869:../os_core/os_task.c **** 
 870:../os_core/os_task.c **** #if OS_TASK_SUSPEND_EN > 0
 871:../os_core/os_task.c **** INT8U  OSTaskSuspend (INT8U prio)
 872:../os_core/os_task.c **** {
 3387              		.loc 1 872 0
 3388              		.cfi_startproc
 3389              		@ Function supports interworking.
 3390              		@ args = 0, pretend = 0, frame = 24
 3391              		@ frame_needed = 1, uses_anonymous_args = 0
 3392 1120 0DC0A0E1 		mov	ip, sp
 3393              	.LCFI18:
 3394              		.cfi_def_cfa_register 12
 3395 1124 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3396 1128 04B04CE2 		sub	fp, ip, #4
 3397              		.cfi_offset 14, -8
 3398              		.cfi_offset 13, -12
 3399              		.cfi_offset 11, -16
 3400              	.LCFI19:
 3401              		.cfi_def_cfa 11, 4
 3402 112c 18D04DE2 		sub	sp, sp, #24
 3403 1130 0030A0E1 		mov	r3, r0
 3404 1134 1D304BE5 		strb	r3, [fp, #-29]
 873:../os_core/os_task.c ****     BOOLEAN    self;
 874:../os_core/os_task.c ****     OS_TCB    *ptcb;
 875:../os_core/os_task.c **** 	INT8U      y;
 876:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 877:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 878:../os_core/os_task.c **** 
 879:../os_core/os_task.c **** 
 880:../os_core/os_task.c **** 
 881:../os_core/os_task.c ****     cpu_sr = 0;                                                 /* Prevent compiler warning        
 882:../os_core/os_task.c **** #endif    
 883:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 884:../os_core/os_task.c ****     if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to suspend idle task
 3405              		.loc 1 884 0
 3406 1138 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3407 113c 3F0053E3 		cmp	r3, #63
 3408 1140 0100001A 		bne	.L101
 885:../os_core/os_task.c ****         return (OS_TASK_SUSPEND_IDLE);
 3409              		.loc 1 885 0
 3410 1144 5B30A0E3 		mov	r3, #91
 3411 1148 630000EA 		b	.L102
 3412              	.L101:
 886:../os_core/os_task.c ****     }
 887:../os_core/os_task.c ****     if (prio >= OS_LOWEST_PRIO) {								/* Task priority valid ?               */
 3413              		.loc 1 887 0
 3414 114c 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3415 1150 3E0053E3 		cmp	r3, #62
 3416 1154 0400009A 		bls	.L103
 888:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {
 3417              		.loc 1 888 0
 3418 1158 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3419 115c FF0053E3 		cmp	r3, #255
 3420 1160 0100000A 		beq	.L103
 889:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 3421              		.loc 1 889 0
 3422 1164 2A30A0E3 		mov	r3, #42
 3423 1168 5B0000EA 		b	.L102
 3424              	.L103:
 890:../os_core/os_task.c ****         }
 891:../os_core/os_task.c ****     }
 892:../os_core/os_task.c **** #endif
 893:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 3425              		.loc 1 893 0
 3426              	@ 893 "../os_core/os_task.c" 1
 3427 116c 00000FE1 		mrs   r0, cpsr              
 3428 1170 04002DE5 	stmfd sp!, {r0}             
 3429 1174 C00080E3 	orr   r0, r0, #0b11000000   
 3430 1178 00F021E1 	msr   cpsr_c, r0              
 3431              	@ 0 "" 2
 894:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF             
 3432              		.loc 1 894 0
 3433 117c 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3434 1180 FF0053E3 		cmp	r3, #255
 3435 1184 0600001A 		bne	.L104
 895:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;
 3436              		.loc 1 895 0
 3437 1188 5C319FE5 		ldr	r3, .L111
 3438 118c 003093E5 		ldr	r3, [r3, #0]
 3439 1190 2E30D3E5 		ldrb	r3, [r3, #46]
 3440 1194 1D304BE5 		strb	r3, [fp, #-29]
 896:../os_core/os_task.c ****         self = TRUE;
 3441              		.loc 1 896 0
 3442 1198 0130A0E3 		mov	r3, #1
 3443 119c 0D304BE5 		strb	r3, [fp, #-13]
 3444 11a0 0A0000EA 		b	.L105
 3445              	.L104:
 897:../os_core/os_task.c ****     } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self          
 3446              		.loc 1 897 0
 3447 11a4 40319FE5 		ldr	r3, .L111
 3448 11a8 003093E5 		ldr	r3, [r3, #0]
 3449 11ac 2E30D3E5 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 3450 11b0 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 3451 11b4 030052E1 		cmp	r2, r3
 3452 11b8 0200001A 		bne	.L106
 898:../os_core/os_task.c ****         self = TRUE;
 3453              		.loc 1 898 0
 3454 11bc 0130A0E3 		mov	r3, #1
 3455 11c0 0D304BE5 		strb	r3, [fp, #-13]
 3456 11c4 010000EA 		b	.L105
 3457              	.L106:
 899:../os_core/os_task.c ****     } else {
 900:../os_core/os_task.c ****         self = FALSE;                                           /* No suspending another task      
 3458              		.loc 1 900 0
 3459 11c8 0030A0E3 		mov	r3, #0
 3460 11cc 0D304BE5 		strb	r3, [fp, #-13]
 3461              	.L105:
 901:../os_core/os_task.c ****     }
 902:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 3462              		.loc 1 902 0
 3463 11d0 1D205BE5 		ldrb	r2, [fp, #-29]	@ zero_extendqisi2
 3464 11d4 14319FE5 		ldr	r3, .L111+4
 3465 11d8 023193E7 		ldr	r3, [r3, r2, asl #2]
 3466 11dc 14300BE5 		str	r3, [fp, #-20]
 903:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist      
 3467              		.loc 1 903 0
 3468 11e0 14301BE5 		ldr	r3, [fp, #-20]
 3469 11e4 000053E3 		cmp	r3, #0
 3470 11e8 0300001A 		bne	.L107
 904:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3471              		.loc 1 904 0
 3472              	@ 904 "../os_core/os_task.c" 1
 3473 11ec 04009DE4 		ldmfd sp!, {r0}             
 3474 11f0 00F021E1 	msr   cpsr_c, r0              
 3475              	@ 0 "" 2
 905:../os_core/os_task.c ****         return (OS_TASK_SUSPEND_PRIO);
 3476              		.loc 1 905 0
 3477 11f4 5A30A0E3 		mov	r3, #90
 3478 11f8 370000EA 		b	.L102
 3479              	.L107:
 906:../os_core/os_task.c ****     }
 907:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                                  /* See if assigned to Mutex        
 3480              		.loc 1 907 0
 3481 11fc 14301BE5 		ldr	r3, [fp, #-20]
 3482 1200 010053E3 		cmp	r3, #1
 3483 1204 0300001A 		bne	.L108
 908:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3484              		.loc 1 908 0
 3485              	@ 908 "../os_core/os_task.c" 1
 3486 1208 04009DE4 		ldmfd sp!, {r0}             
 3487 120c 00F021E1 	msr   cpsr_c, r0              
 3488              	@ 0 "" 2
 909:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 3489              		.loc 1 909 0
 3490 1210 0B30A0E3 		mov	r3, #11
 3491 1214 300000EA 		b	.L102
 3492              	.L108:
 910:../os_core/os_task.c ****     }
 911:../os_core/os_task.c **** 	y            = ptcb->OSTCBY;
 3493              		.loc 1 911 0
 3494 1218 14301BE5 		ldr	r3, [fp, #-20]
 3495 121c 3030D3E5 		ldrb	r3, [r3, #48]
 3496 1220 15304BE5 		strb	r3, [fp, #-21]
 912:../os_core/os_task.c **** 	OSRdyTbl[y] &= ~ptcb->OSTCBBitX;							/* Make task not ready                 */
 3497              		.loc 1 912 0
 3498 1224 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3499 1228 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3500 122c C0109FE5 		ldr	r1, .L111+8
 3501 1230 0220D1E7 		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 3502 1234 FF1002E2 		and	r1, r2, #255
 3503 1238 14201BE5 		ldr	r2, [fp, #-20]
 3504 123c 3120D2E5 		ldrb	r2, [r2, #49]	@ zero_extendqisi2
 3505 1240 FF2002E2 		and	r2, r2, #255
 3506 1244 0220E0E1 		mvn	r2, r2
 3507 1248 FF2002E2 		and	r2, r2, #255
 3508 124c 022001E0 		and	r2, r1, r2
 3509 1250 FF2002E2 		and	r2, r2, #255
 3510 1254 FF1002E2 		and	r1, r2, #255
 3511 1258 94209FE5 		ldr	r2, .L111+8
 3512 125c 0310C2E7 		strb	r1, [r2, r3]
 913:../os_core/os_task.c ****     if (OSRdyTbl[y] == 0x00) { 
 3513              		.loc 1 913 0
 3514 1260 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3515 1264 88209FE5 		ldr	r2, .L111+8
 3516 1268 0330D2E7 		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 3517 126c 000053E3 		cmp	r3, #0
 3518 1270 0C00001A 		bne	.L109
 914:../os_core/os_task.c ****         OSRdyGrp &= ~ptcb->OSTCBBitY;
 3519              		.loc 1 914 0
 3520 1274 14301BE5 		ldr	r3, [fp, #-20]
 3521 1278 3230D3E5 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 3522 127c FF3003E2 		and	r3, r3, #255
 3523 1280 0330E0E1 		mvn	r3, r3
 3524 1284 FF2003E2 		and	r2, r3, #255
 3525 1288 68309FE5 		ldr	r3, .L111+12
 3526 128c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3527 1290 FF3003E2 		and	r3, r3, #255
 3528 1294 033002E0 		and	r3, r2, r3
 3529 1298 FF3003E2 		and	r3, r3, #255
 3530 129c FF2003E2 		and	r2, r3, #255
 3531 12a0 50309FE5 		ldr	r3, .L111+12
 3532 12a4 0020C3E5 		strb	r2, [r3, #0]
 3533              	.L109:
 915:../os_core/os_task.c ****     }
 916:../os_core/os_task.c ****     ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'   
 3534              		.loc 1 916 0
 3535 12a8 14301BE5 		ldr	r3, [fp, #-20]
 3536 12ac 2C30D3E5 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 3537 12b0 083083E3 		orr	r3, r3, #8
 3538 12b4 FF2003E2 		and	r2, r3, #255
 3539 12b8 14301BE5 		ldr	r3, [fp, #-20]
 3540 12bc 2C20C3E5 		strb	r2, [r3, #44]
 917:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 3541              		.loc 1 917 0
 3542              	@ 917 "../os_core/os_task.c" 1
 3543 12c0 04009DE4 		ldmfd sp!, {r0}             
 3544 12c4 00F021E1 	msr   cpsr_c, r0              
 3545              	@ 0 "" 2
 918:../os_core/os_task.c ****     if (self == TRUE) {                                         /* Context switch only if SELF     
 3546              		.loc 1 918 0
 3547 12c8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3548 12cc 010053E3 		cmp	r3, #1
 3549 12d0 0000001A 		bne	.L110
 919:../os_core/os_task.c ****         OS_Sched();
 3550              		.loc 1 919 0
 3551 12d4 FEFFFFEB 		bl	OS_Sched
 3552              	.L110:
 920:../os_core/os_task.c ****     }
 921:../os_core/os_task.c ****     return (OS_NO_ERR);
 3553              		.loc 1 921 0
 3554 12d8 0030A0E3 		mov	r3, #0
 3555              	.L102:
 922:../os_core/os_task.c **** }
 3556              		.loc 1 922 0
 3557 12dc 0300A0E1 		mov	r0, r3
 3558 12e0 0CD04BE2 		sub	sp, fp, #12
 3559 12e4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3560 12e8 1EFF2FE1 		bx	lr
 3561              	.L112:
 3562              		.align	2
 3563              	.L111:
 3564 12ec 00000000 		.word	OSTCBCur
 3565 12f0 00000000 		.word	OSTCBPrioTbl
 3566 12f4 00000000 		.word	OSRdyTbl
 3567 12f8 00000000 		.word	OSRdyGrp
 3568              		.cfi_endproc
 3569              	.LFE9:
 3571              		.align	2
 3572              		.global	OSTaskQuery
 3574              	OSTaskQuery:
 3575              	.LFB10:
 923:../os_core/os_task.c **** #endif
 924:../os_core/os_task.c **** /*$PAGE*/
 925:../os_core/os_task.c **** /*
 926:../os_core/os_task.c **** ***************************************************************************************************
 927:../os_core/os_task.c **** *                                            QUERY A TASK
 928:../os_core/os_task.c **** *
 929:../os_core/os_task.c **** * Description: This function is called to obtain a copy of the desired task's TCB.
 930:../os_core/os_task.c **** *
 931:../os_core/os_task.c **** * Arguments  : prio         is the priority of the task to obtain information from.
 932:../os_core/os_task.c **** *
 933:../os_core/os_task.c **** *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
 934:../os_core/os_task.c **** *
 935:../os_core/os_task.c **** * Returns    : OS_NO_ERR          if the requested task is suspended
 936:../os_core/os_task.c **** *              OS_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
 937:../os_core/os_task.c **** *                                 (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 938:../os_core/os_task.c **** *              OS_PRIO_ERR        if the desired task has not been created
 939:../os_core/os_task.c **** *              OS_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
 940:../os_core/os_task.c **** ***************************************************************************************************
 941:../os_core/os_task.c **** */
 942:../os_core/os_task.c **** 
 943:../os_core/os_task.c **** #if OS_TASK_QUERY_EN > 0
 944:../os_core/os_task.c **** INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
 945:../os_core/os_task.c **** {
 3576              		.loc 1 945 0
 3577              		.cfi_startproc
 3578              		@ Function supports interworking.
 3579              		@ args = 0, pretend = 0, frame = 16
 3580              		@ frame_needed = 1, uses_anonymous_args = 0
 3581 12fc 0DC0A0E1 		mov	ip, sp
 3582              	.LCFI20:
 3583              		.cfi_def_cfa_register 12
 3584 1300 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3585 1304 04B04CE2 		sub	fp, ip, #4
 3586              		.cfi_offset 14, -8
 3587              		.cfi_offset 13, -12
 3588              		.cfi_offset 11, -16
 3589              	.LCFI21:
 3590              		.cfi_def_cfa 11, 4
 3591 1308 10D04DE2 		sub	sp, sp, #16
 3592 130c 0030A0E1 		mov	r3, r0
 3593 1310 1C100BE5 		str	r1, [fp, #-28]
 3594 1314 15304BE5 		strb	r3, [fp, #-21]
 946:../os_core/os_task.c ****     OS_TCB    *ptcb;
 947:../os_core/os_task.c **** #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register       
 948:../os_core/os_task.c ****     OS_CPU_SR  cpu_sr;
 949:../os_core/os_task.c **** 
 950:../os_core/os_task.c **** 
 951:../os_core/os_task.c **** 
 952:../os_core/os_task.c ****     cpu_sr = 0;                                  /* Prevent compiler warning                       
 953:../os_core/os_task.c **** #endif    
 954:../os_core/os_task.c **** #if OS_ARG_CHK_EN > 0
 955:../os_core/os_task.c ****     if (prio > OS_LOWEST_PRIO) {				 /* Task priority valid ?    	                       */
 3595              		.loc 1 955 0
 3596 1318 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3597 131c 3F0053E3 		cmp	r3, #63
 3598 1320 0400009A 		bls	.L114
 956:../os_core/os_task.c ****         if (prio != OS_PRIO_SELF) {   
 3599              		.loc 1 956 0
 3600 1324 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3601 1328 FF0053E3 		cmp	r3, #255
 3602 132c 0100000A 		beq	.L114
 957:../os_core/os_task.c ****             return (OS_PRIO_INVALID);
 3603              		.loc 1 957 0
 3604 1330 2A30A0E3 		mov	r3, #42
 3605 1334 250000EA 		b	.L115
 3606              	.L114:
 958:../os_core/os_task.c ****         }
 959:../os_core/os_task.c ****     }
 960:../os_core/os_task.c **** #endif
 961:../os_core/os_task.c ****     OS_ENTER_CRITICAL();
 3607              		.loc 1 961 0
 3608              	@ 961 "../os_core/os_task.c" 1
 3609 1338 00000FE1 		mrs   r0, cpsr              
 3610 133c 04002DE5 	stmfd sp!, {r0}             
 3611 1340 C00080E3 	orr   r0, r0, #0b11000000   
 3612 1344 00F021E1 	msr   cpsr_c, r0              
 3613              	@ 0 "" 2
 962:../os_core/os_task.c ****     if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                            
 3614              		.loc 1 962 0
 3615 1348 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3616 134c FF0053E3 		cmp	r3, #255
 3617 1350 0300001A 		bne	.L116
 963:../os_core/os_task.c ****         prio = OSTCBCur->OSTCBPrio;
 3618              		.loc 1 963 0
 3619 1354 84309FE5 		ldr	r3, .L119
 3620 1358 003093E5 		ldr	r3, [r3, #0]
 3621 135c 2E30D3E5 		ldrb	r3, [r3, #46]
 3622 1360 15304BE5 		strb	r3, [fp, #-21]
 3623              	.L116:
 964:../os_core/os_task.c ****     }
 965:../os_core/os_task.c ****     ptcb = OSTCBPrioTbl[prio];
 3624              		.loc 1 965 0
 3625 1364 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3626 1368 74309FE5 		ldr	r3, .L119+4
 3627 136c 023193E7 		ldr	r3, [r3, r2, asl #2]
 3628 1370 10300BE5 		str	r3, [fp, #-16]
 966:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                       
 3629              		.loc 1 966 0
 3630 1374 10301BE5 		ldr	r3, [fp, #-16]
 3631 1378 000053E3 		cmp	r3, #0
 3632 137c 0300001A 		bne	.L117
 967:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3633              		.loc 1 967 0
 3634              	@ 967 "../os_core/os_task.c" 1
 3635 1380 04009DE4 		ldmfd sp!, {r0}             
 3636 1384 00F021E1 	msr   cpsr_c, r0              
 3637              	@ 0 "" 2
 968:../os_core/os_task.c ****         return (OS_PRIO_ERR);
 3638              		.loc 1 968 0
 3639 1388 2930A0E3 		mov	r3, #41
 3640 138c 0F0000EA 		b	.L115
 3641              	.L117:
 969:../os_core/os_task.c ****     }
 970:../os_core/os_task.c ****     if (ptcb == (OS_TCB *)1) {                   /* Task to query must not be assigned to a Mutex  
 3642              		.loc 1 970 0
 3643 1390 10301BE5 		ldr	r3, [fp, #-16]
 3644 1394 010053E3 		cmp	r3, #1
 3645 1398 0300001A 		bne	.L118
 971:../os_core/os_task.c ****         OS_EXIT_CRITICAL();
 3646              		.loc 1 971 0
 3647              	@ 971 "../os_core/os_task.c" 1
 3648 139c 04009DE4 		ldmfd sp!, {r0}             
 3649 13a0 00F021E1 	msr   cpsr_c, r0              
 3650              	@ 0 "" 2
 972:../os_core/os_task.c ****         return (OS_TASK_NOT_EXIST);
 3651              		.loc 1 972 0
 3652 13a4 0B30A0E3 		mov	r3, #11
 3653 13a8 080000EA 		b	.L115
 3654              	.L118:
 973:../os_core/os_task.c ****     }
 974:../os_core/os_task.c ****                                                  /* Copy TCB into user storage area                
 975:../os_core/os_task.c ****     OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));  
 3655              		.loc 1 975 0
 3656 13ac 1C201BE5 		ldr	r2, [fp, #-28]
 3657 13b0 10301BE5 		ldr	r3, [fp, #-16]
 3658 13b4 0200A0E1 		mov	r0, r2
 3659 13b8 0310A0E1 		mov	r1, r3
 3660 13bc 6820A0E3 		mov	r2, #104
 3661 13c0 FEFFFFEB 		bl	OS_MemCopy
 976:../os_core/os_task.c ****     OS_EXIT_CRITICAL();
 3662              		.loc 1 976 0
 3663              	@ 976 "../os_core/os_task.c" 1
 3664 13c4 04009DE4 		ldmfd sp!, {r0}             
 3665 13c8 00F021E1 	msr   cpsr_c, r0              
 3666              	@ 0 "" 2
 977:../os_core/os_task.c ****     return (OS_NO_ERR);
 3667              		.loc 1 977 0
 3668 13cc 0030A0E3 		mov	r3, #0
 3669              	.L115:
 978:../os_core/os_task.c **** }
 3670              		.loc 1 978 0
 3671 13d0 0300A0E1 		mov	r0, r3
 3672 13d4 0CD04BE2 		sub	sp, fp, #12
 3673 13d8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3674 13dc 1EFF2FE1 		bx	lr
 3675              	.L120:
 3676              		.align	2
 3677              	.L119:
 3678 13e0 00000000 		.word	OSTCBCur
 3679 13e4 00000000 		.word	OSTCBPrioTbl
 3680              		.cfi_endproc
 3681              	.LFE10:
 3683              		.align	2
 3684              		.global	OS_TaskStkClr
 3686              	OS_TaskStkClr:
 3687              	.LFB11:
 979:../os_core/os_task.c **** #endif
 980:../os_core/os_task.c **** /*$PAGE*/
 981:../os_core/os_task.c **** /*
 982:../os_core/os_task.c **** ***************************************************************************************************
 983:../os_core/os_task.c **** *                                        CLEAR TASK STACK
 984:../os_core/os_task.c **** *
 985:../os_core/os_task.c **** * Description: This function is used to clear the stack of a task (i.e. write all zeros)
 986:../os_core/os_task.c **** *
 987:../os_core/os_task.c **** * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
 988:../os_core/os_task.c **** *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from
 989:../os_core/os_task.c **** *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
 990:../os_core/os_task.c **** *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to 
 991:../os_core/os_task.c **** *                       highest memory location of the stack and the stack will grow with increasin
 992:../os_core/os_task.c **** *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
 993:../os_core/os_task.c **** *
 994:../os_core/os_task.c **** *              size     is the number of 'stack elements' to clear.
 995:../os_core/os_task.c **** *
 996:../os_core/os_task.c **** *              opt      contains additional information (or options) about the behavior of the task
 997:../os_core/os_task.c **** *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be applica
 998:../os_core/os_task.c **** *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
 999:../os_core/os_task.c **** *
1000:../os_core/os_task.c **** * Returns    : none
1001:../os_core/os_task.c **** ***************************************************************************************************
1002:../os_core/os_task.c **** */
1003:../os_core/os_task.c **** #if OS_TASK_CREATE_EXT_EN > 0
1004:../os_core/os_task.c **** void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
1005:../os_core/os_task.c **** {
 3688              		.loc 1 1005 0
 3689              		.cfi_startproc
 3690              		@ Function supports interworking.
 3691              		@ args = 0, pretend = 0, frame = 16
 3692              		@ frame_needed = 1, uses_anonymous_args = 0
 3693 13e8 0DC0A0E1 		mov	ip, sp
 3694              	.LCFI22:
 3695              		.cfi_def_cfa_register 12
 3696 13ec 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3697 13f0 04B04CE2 		sub	fp, ip, #4
 3698              		.cfi_offset 14, -8
 3699              		.cfi_offset 13, -12
 3700              		.cfi_offset 11, -16
 3701              	.LCFI23:
 3702              		.cfi_def_cfa 11, 4
 3703 13f4 10D04DE2 		sub	sp, sp, #16
 3704 13f8 10000BE5 		str	r0, [fp, #-16]
 3705 13fc 14100BE5 		str	r1, [fp, #-20]
 3706 1400 0230A0E1 		mov	r3, r2
 3707 1404 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
1006:../os_core/os_task.c ****     if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled   
 3708              		.loc 1 1006 0
 3709 1408 B6315BE1 		ldrh	r3, [fp, #-22]
 3710 140c 013003E2 		and	r3, r3, #1
 3711 1410 FF3003E2 		and	r3, r3, #255
 3712 1414 000053E3 		cmp	r3, #0
 3713 1418 1000000A 		beq	.L121
1007:../os_core/os_task.c ****         if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared         
 3714              		.loc 1 1007 0
 3715 141c B6315BE1 		ldrh	r3, [fp, #-22]
 3716 1420 023003E2 		and	r3, r3, #2
 3717 1424 000053E3 		cmp	r3, #0
 3718 1428 0C00000A 		beq	.L121
1008:../os_core/os_task.c **** #if OS_STK_GROWTH == 1                     
1009:../os_core/os_task.c ****             while (size > 0) {                         /* Stack grows from HIGH to LOW memory      
 3719              		.loc 1 1009 0
 3720 142c 080000EA 		b	.L123
 3721              	.L124:
1010:../os_core/os_task.c ****                 size--;
 3722              		.loc 1 1010 0
 3723 1430 14301BE5 		ldr	r3, [fp, #-20]
 3724 1434 013043E2 		sub	r3, r3, #1
 3725 1438 14300BE5 		str	r3, [fp, #-20]
1011:../os_core/os_task.c ****                 *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!       
 3726              		.loc 1 1011 0
 3727 143c 10301BE5 		ldr	r3, [fp, #-16]
 3728 1440 0020A0E3 		mov	r2, #0
 3729 1444 002083E5 		str	r2, [r3, #0]
 3730 1448 10301BE5 		ldr	r3, [fp, #-16]
 3731 144c 043083E2 		add	r3, r3, #4
 3732 1450 10300BE5 		str	r3, [fp, #-16]
 3733              	.L123:
1009:../os_core/os_task.c ****             while (size > 0) {                         /* Stack grows from HIGH to LOW memory      
 3734              		.loc 1 1009 0 discriminator 1
 3735 1454 14301BE5 		ldr	r3, [fp, #-20]
 3736 1458 000053E3 		cmp	r3, #0
 3737 145c F3FFFF1A 		bne	.L124
 3738              	.L121:
1012:../os_core/os_task.c ****             }
1013:../os_core/os_task.c **** #else
1014:../os_core/os_task.c ****             while (size > 0) {                         /* Stack grows from LOW to HIGH memory      
1015:../os_core/os_task.c ****                 size--;
1016:../os_core/os_task.c ****                 *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down      
1017:../os_core/os_task.c ****             }
1018:../os_core/os_task.c **** #endif
1019:../os_core/os_task.c ****         }
1020:../os_core/os_task.c ****     }
1021:../os_core/os_task.c **** }
 3739              		.loc 1 1021 0
 3740 1460 0CD04BE2 		sub	sp, fp, #12
 3741 1464 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3742 1468 1EFF2FE1 		bx	lr
 3743              		.cfi_endproc
 3744              	.LFE11:
 3746              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 os_task.c
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:1635   .text:00000000 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:1638   .text:00000000 OSTaskChangePrio
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:1959   .text:000003b0 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:1967   .text:000003c4 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:1970   .text:000003c4 OSTaskCreate
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2110   .text:00000514 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2116   .text:00000520 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2119   .text:00000520 OSTaskCreateExt
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3686   .text:000013e8 OS_TaskStkClr
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2265   .text:00000684 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2271   .text:00000690 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2274   .text:00000690 OSTaskDel
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2610   .text:00000a48 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2622   .text:00000a6c $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2625   .text:00000a6c OSTaskDelReq
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2748   .text:00000b74 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2753   .text:00000b7c $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2756   .text:00000b7c OSTaskNameGet
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2890   .text:00000cb8 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2895   .text:00000cc0 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:2898   .text:00000cc0 OSTaskNameSet
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3044   .text:00000e10 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3049   .text:00000e18 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3052   .text:00000e18 OSTaskResume
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3205   .text:00000f80 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3211   .text:00000f8c $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3214   .text:00000f8c OSTaskStkChk
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3377   .text:00001118 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3382   .text:00001120 $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3385   .text:00001120 OSTaskSuspend
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3564   .text:000012ec $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3571   .text:000012fc $a
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3574   .text:000012fc OSTaskQuery
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3678   .text:000013e0 $d
C:\Users\USUARI~1\AppData\Local\Temp\cctCWfxc.s:3683   .text:000013e8 $a
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
OS_Sched
OSTCBPrioTbl
OSTCBCur
OSMapTbl
OSRdyTbl
OSRdyGrp
OSTaskStkInit
OS_TCBInit
OSIntNesting
OSRunning
OS_FlagUnlink
OS_Dummy
OSTaskDelHook
OSLockNesting
OSTaskCtr
OSTCBList
OSTCBFreeList
OS_StrCopy
OS_StrLen
OS_MemCopy
